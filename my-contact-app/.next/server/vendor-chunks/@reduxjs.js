"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnhancerArray: () => (/* binding */ EnhancerArray),\n/* harmony export */   MiddlewareArray: () => (/* binding */ MiddlewareArray),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   getDefaultMiddleware: () => (/* binding */ getDefaultMiddleware),\n/* harmony export */   getType: () => (/* binding */ getType),\n/* harmony export */   isAction: () => (/* binding */ isAction),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult)\n/* harmony export */ });\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.esm.mjs\");\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/es/redux.js\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/es/index.js\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/es/index.js\");\nvar __extends = undefined && undefined.__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar __spreadArray = undefined && undefined.__spreadArray || function(to, from) {\n    for(var i = 0, il = from.length, j = to.length; i < il; i++, j++)to[j] = from[i];\n    return to;\n};\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __spreadValues = function(a, b) {\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for(var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++){\n        var prop = _c[_i];\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = function(a, b) {\n    return __defProps(a, __getOwnPropDescs(b));\n};\nvar __async = function(__this, __arguments, generator) {\n    return new Promise(function(resolve, reject) {\n        var fulfilled = function(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = function(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = function(x) {\n            return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        };\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/index.ts\n\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelector = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    var selector = reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector.apply(void 0, args);\n    var wrappedSelector = function(value) {\n        var rest = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            rest[_i - 1] = arguments[_i];\n        }\n        return selector.apply(void 0, __spreadArray([\n            (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value\n        ], rest));\n    };\n    return wrappedSelector;\n};\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop2) {\n        return noop2;\n    };\n};\n// src/isPlainObject.ts\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) return false;\n    var proto = Object.getPrototypeOf(value);\n    if (proto === null) return true;\n    var baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/getDefaultMiddleware.ts\n\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    var elapsed = 0;\n    return {\n        measureTime: function(fn) {\n            var started = Date.now();\n            try {\n                return fn();\n            } finally{\n                var finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded: function() {\n            if (elapsed > maxDelay) {\n                console.warn(fnName + \" took \" + elapsed + \"ms, which is more than the warning threshold of \" + maxDelay + \"ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.\");\n            }\n        }\n    };\n}\nvar MiddlewareArray = /** @class */ function(_super) {\n    __extends(MiddlewareArray, _super);\n    function MiddlewareArray() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        Object.setPrototypeOf(_this, MiddlewareArray.prototype);\n        return _this;\n    }\n    Object.defineProperty(MiddlewareArray, Symbol.species, {\n        get: function() {\n            return MiddlewareArray;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MiddlewareArray.prototype.concat = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        return _super.prototype.concat.apply(this, arr);\n    };\n    MiddlewareArray.prototype.prepend = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n                void 0\n            ], arr[0].concat(this))))();\n        }\n        return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n            void 0\n        ], arr.concat(this))))();\n    };\n    return MiddlewareArray;\n}(Array);\nvar EnhancerArray = /** @class */ function(_super) {\n    __extends(EnhancerArray, _super);\n    function EnhancerArray() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        Object.setPrototypeOf(_this, EnhancerArray.prototype);\n        return _this;\n    }\n    Object.defineProperty(EnhancerArray, Symbol.species, {\n        get: function() {\n            return EnhancerArray;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EnhancerArray.prototype.concat = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        return _super.prototype.concat.apply(this, arr);\n    };\n    EnhancerArray.prototype.prepend = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([\n                void 0\n            ], arr[0].concat(this))))();\n        }\n        return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([\n            void 0\n        ], arr.concat(this))))();\n    };\n    return EnhancerArray;\n}(Array);\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(val, function() {}) : val;\n}\n// src/immutableStateInvariantMiddleware.ts\nvar isProduction = \"development\" === \"production\";\nvar prefix = \"Invariant failed\";\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + \": \" + (message || \"\"));\n}\nfunction stringify(obj, serializer, indent, decycler) {\n    return JSON.stringify(obj, getSerialize(serializer, decycler), indent);\n}\nfunction getSerialize(serializer, decycler) {\n    var stack = [], keys = [];\n    if (!decycler) decycler = function(_, value) {\n        if (stack[0] === value) return \"[Circular ~]\";\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n    };\n    return function(key, value) {\n        if (stack.length > 0) {\n            var thisPos = stack.indexOf(this);\n            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n            if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n        } else stack.push(value);\n        return serializer == null ? value : serializer.call(this, key, value);\n    };\n}\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations: function() {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths, obj, path) {\n    if (ignorePaths === void 0) {\n        ignorePaths = [];\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    var tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj)) {\n        tracked.children = {};\n        for(var key in obj){\n            var childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths, trackedProperty, obj, sameParentRef, path) {\n    if (ignoredPaths === void 0) {\n        ignoredPaths = [];\n    }\n    if (sameParentRef === void 0) {\n        sameParentRef = false;\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    var prevObj = trackedProperty ? trackedProperty.value : void 0;\n    var sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path: path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    var keysToDetect = {};\n    for(var key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(var key in obj){\n        keysToDetect[key] = true;\n    }\n    var hasIgnoredPaths = ignoredPaths.length > 0;\n    var _loop_1 = function(key) {\n        var nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            var hasMatches = ignoredPaths.some(function(ignored) {\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                return \"continue\";\n            }\n        }\n        var result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return {\n                value: result\n            };\n        }\n    };\n    for(var key in keysToDetect){\n        var state_1 = _loop_1(key);\n        if (typeof state_1 === \"object\") return state_1.value;\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options.ignoredPaths, _d = options.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options.ignore;\n    ignoredPaths = ignoredPaths || ignore;\n    var track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return function(_c) {\n        var getState = _c.getState;\n        var state = getState();\n        var tracker = track(state);\n        var result;\n        return function(next) {\n            return function(action) {\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    invariant(!result.wasMutated, \"A state mutation was detected between dispatches, in the path '\" + (result.path || \"\") + \"'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                var dispatchedAction = next(action);\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    result.wasMutated && invariant(!result.wasMutated, \"A state mutation was detected inside a dispatch, in the path: \" + (result.path || \"\") + \". Take a look at the reducer(s) handling the action \" + stringify(action) + \". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                measureUtils.warnIfExceeded();\n                return dispatchedAction;\n            };\n        };\n    };\n}\n// src/serializableStateInvariantMiddleware.ts\nfunction isPlain(val) {\n    var type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || isPlainObject(val);\n}\nfunction findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths, cache) {\n    if (path === void 0) {\n        path = \"\";\n    }\n    if (isSerializable === void 0) {\n        isSerializable = isPlain;\n    }\n    if (ignoredPaths === void 0) {\n        ignoredPaths = [];\n    }\n    var foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value: value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache == null ? void 0 : cache.has(value)) return false;\n    var entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    var hasIgnoredPaths = ignoredPaths.length > 0;\n    var _loop_2 = function(key, nestedValue) {\n        var nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            var hasMatches = ignoredPaths.some(function(ignored) {\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                return \"continue\";\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                value: {\n                    keyPath: nestedPath,\n                    value: nestedValue\n                }\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return {\n                    value: foundNestedSerializable\n                };\n            }\n        }\n    };\n    for(var _i = 0, entries_1 = entries; _i < entries_1.length; _i++){\n        var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];\n        var state_2 = _loop_2(key, nestedValue);\n        if (typeof state_2 === \"object\") return state_2.value;\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for(var _i = 0, _c = Object.values(value); _i < _c.length; _i++){\n        var nestedValue = _c[_i];\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options.getEntries, _d = options.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? [\n        \"meta.arg\",\n        \"meta.baseQueryMeta\"\n    ] : _e, _f = options.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options.ignoreActions, ignoreActions = _j === void 0 ? false : _j, _k = options.disableCache, disableCache = _k === void 0 ? false : _k;\n    var cache = !disableCache && WeakSet ? new WeakSet() : void 0;\n    return function(storeAPI) {\n        return function(next) {\n            return function(action) {\n                var result = next(action);\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                    measureUtils.measureTime(function() {\n                        var foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                        if (foundActionNonSerializableValue) {\n                            var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in an action, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                        }\n                    });\n                }\n                if (!ignoreState) {\n                    measureUtils.measureTime(function() {\n                        var state = storeAPI.getState();\n                        var foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                        if (foundStateNonSerializableValue) {\n                            var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in the state, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the reducer(s) handling this action type: \" + action.type + \".\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)\");\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                }\n                return result;\n            };\n        };\n    };\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nfunction curryGetDefaultMiddleware() {\n    return function curriedGetDefaultMiddleware(options) {\n        return getDefaultMiddleware(options);\n    };\n}\nfunction getDefaultMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = options.thunk, thunk = _c === void 0 ? true : _c, _d = options.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options.serializableCheck, serializableCheck = _e === void 0 ? true : _e;\n    var middlewareArray = new MiddlewareArray();\n    if (thunk) {\n        if (isBoolean(thunk)) {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n        } else {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"].withExtraArgument(thunk.extraArgument));\n        }\n    }\n    if (true) {\n        if (immutableCheck) {\n            var immutableOptions = {};\n            if (!isBoolean(immutableCheck)) {\n                immutableOptions = immutableCheck;\n            }\n            middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n        }\n        if (serializableCheck) {\n            var serializableOptions = {};\n            if (!isBoolean(serializableCheck)) {\n                serializableOptions = serializableCheck;\n            }\n            middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n        }\n    }\n    return middlewareArray;\n}\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n    var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();\n    var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;\n    var rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if (isPlainObject(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error('\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');\n    }\n    var finalMiddleware = middleware;\n    if (typeof finalMiddleware === \"function\") {\n        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error(\"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some(function(item) {\n        return typeof item !== \"function\";\n    })) {\n        throw new Error(\"each middleware provided to configureStore must be a function\");\n    }\n    var middlewareEnhancer = redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware.apply(void 0, finalMiddleware);\n    var finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools(__spreadValues({\n            trace: !IS_PRODUCTION\n        }, typeof devTools === \"object\" && devTools));\n    }\n    var defaultEnhancers = new EnhancerArray(middlewareEnhancer);\n    var storeEnhancers = defaultEnhancers;\n    if (Array.isArray(enhancers)) {\n        storeEnhancers = __spreadArray([\n            middlewareEnhancer\n        ], enhancers);\n    } else if (typeof enhancers === \"function\") {\n        storeEnhancers = enhancers(defaultEnhancers);\n    }\n    var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        if (prepareAction) {\n            var prepared = prepareAction.apply(void 0, args);\n            if (!prepared) {\n                throw new Error(\"prepareAction did not return an object\");\n            }\n            return __spreadValues(__spreadValues({\n                type: type,\n                payload: prepared.payload\n            }, \"meta\" in prepared && {\n                meta: prepared.meta\n            }), \"error\" in prepared && {\n                error: prepared.error\n            });\n        }\n        return {\n            type: type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = function() {\n        return \"\" + type;\n    };\n    actionCreator.type = type;\n    actionCreator.match = function(action) {\n        return action.type === type;\n    };\n    return actionCreator;\n}\nfunction isAction(action) {\n    return isPlainObject(action) && \"type\" in action;\n}\nfunction isFSA(action) {\n    return isAction(action) && typeof action.type === \"string\" && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\nfunction getType(actionCreator) {\n    return \"\" + actionCreator;\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    var actionsMap = {};\n    var actionMatchers = [];\n    var defaultCaseReducer;\n    var builder = {\n        addCase: function(typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            var type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (type in actionsMap) {\n                throw new Error(\"addCase cannot be called with two reducers for the same action type\");\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher: function(matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher: matcher,\n                reducer: reducer\n            });\n            return builder;\n        },\n        addDefaultCase: function(reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nvar hasWarnedAboutObjectNotation = false;\nfunction createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {\n    if (actionMatchers === void 0) {\n        actionMatchers = [];\n    }\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            if (!hasWarnedAboutObjectNotation) {\n                hasWarnedAboutObjectNotation = true;\n                console.warn(\"The object notation for `createReducer` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n            }\n        }\n    }\n    var _c = typeof mapOrBuilderCallback === \"function\" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [\n        mapOrBuilderCallback,\n        actionMatchers,\n        defaultCaseReducer\n    ], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];\n    var getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = function() {\n            return freezeDraftable(initialState());\n        };\n    } else {\n        var frozenInitialState_1 = freezeDraftable(initialState);\n        getInitialState = function() {\n            return frozenInitialState_1;\n        };\n    }\n    function reducer(state, action) {\n        if (state === void 0) {\n            state = getInitialState();\n        }\n        var caseReducers = __spreadArray([\n            actionsMap[action.type]\n        ], finalActionMatchers.filter(function(_c) {\n            var matcher = _c.matcher;\n            return matcher(action);\n        }).map(function(_c) {\n            var reducer2 = _c.reducer;\n            return reducer2;\n        }));\n        if (caseReducers.filter(function(cr) {\n            return !!cr;\n        }).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce(function(previousState, caseReducer) {\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    var draft = previousState;\n                    var result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    var result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw Error(\"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(previousState, function(draft) {\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/createSlice.ts\nvar hasWarnedAboutObjectNotation2 = false;\nfunction getType2(slice, actionKey) {\n    return slice + \"/\" + actionKey;\n}\nfunction createSlice(options) {\n    var name = options.name;\n    if (!name) {\n        throw new Error(\"`name` is a required option for createSlice\");\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        if (options.initialState === void 0) {\n            console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n        }\n    }\n    var initialState = typeof options.initialState == \"function\" ? options.initialState : freezeDraftable(options.initialState);\n    var reducers = options.reducers || {};\n    var reducerNames = Object.keys(reducers);\n    var sliceCaseReducersByName = {};\n    var sliceCaseReducersByType = {};\n    var actionCreators = {};\n    reducerNames.forEach(function(reducerName) {\n        var maybeReducerWithPrepare = reducers[reducerName];\n        var type = getType2(name, reducerName);\n        var caseReducer;\n        var prepareCallback;\n        if (\"reducer\" in maybeReducerWithPrepare) {\n            caseReducer = maybeReducerWithPrepare.reducer;\n            prepareCallback = maybeReducerWithPrepare.prepare;\n        } else {\n            caseReducer = maybeReducerWithPrepare;\n        }\n        sliceCaseReducersByName[reducerName] = caseReducer;\n        sliceCaseReducersByType[type] = caseReducer;\n        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);\n    });\n    function buildReducer() {\n        if (true) {\n            if (typeof options.extraReducers === \"object\") {\n                if (!hasWarnedAboutObjectNotation2) {\n                    hasWarnedAboutObjectNotation2 = true;\n                    console.warn(\"The object notation for `createSlice.extraReducers` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n        }\n        var _c = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n            options.extraReducers\n        ], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;\n        var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);\n        return createReducer(initialState, function(builder) {\n            for(var key in finalCaseReducers){\n                builder.addCase(key, finalCaseReducers[key]);\n            }\n            for(var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++){\n                var m = actionMatchers_1[_i];\n                builder.addMatcher(m.matcher, m.reducer);\n            }\n            if (defaultCaseReducer) {\n                builder.addDefaultCase(defaultCaseReducer);\n            }\n        });\n    }\n    var _reducer;\n    return {\n        name: name,\n        reducer: function(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        },\n        actions: actionCreators,\n        caseReducers: sliceCaseReducersByName,\n        getInitialState: function() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n    };\n}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory() {\n    function getInitialState(additionalState) {\n        if (additionalState === void 0) {\n            additionalState = {};\n        }\n        return Object.assign(getInitialEntityState(), additionalState);\n    }\n    return {\n        getInitialState: getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState) {\n        var selectIds = function(state) {\n            return state.ids;\n        };\n        var selectEntities = function(state) {\n            return state.entities;\n        };\n        var selectAll = createDraftSafeSelector(selectIds, selectEntities, function(ids, entities) {\n            return ids.map(function(id) {\n                return entities[id];\n            });\n        });\n        var selectId = function(_, id) {\n            return id;\n        };\n        var selectById = function(entities, id) {\n            return entities[id];\n        };\n        var selectTotal = createDraftSafeSelector(selectIds, function(ids) {\n            return ids.length;\n        });\n        if (!selectState) {\n            return {\n                selectIds: selectIds,\n                selectEntities: selectEntities,\n                selectAll: selectAll,\n                selectTotal: selectTotal,\n                selectById: createDraftSafeSelector(selectEntities, selectId, selectById)\n            };\n        }\n        var selectGlobalizedEntities = createDraftSafeSelector(selectState, selectEntities);\n        return {\n            selectIds: createDraftSafeSelector(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createDraftSafeSelector(selectState, selectAll),\n            selectTotal: createDraftSafeSelector(selectState, selectTotal),\n            selectById: createDraftSafeSelector(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors: getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nfunction createSingleArgumentStateOperator(mutator) {\n    var operator = createStateOperator(function(_, state) {\n        return mutator(state);\n    });\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        var runMutator = function(draft) {\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(state)) {\n            runMutator(state);\n            return state;\n        } else {\n            return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state, runMutator);\n        }\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    var key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    var added = [];\n    var updated = [];\n    for(var _i = 0, newEntities_1 = newEntities; _i < newEntities_1.length; _i++){\n        var entity = newEntities_1[_i];\n        var id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id: id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_2 = newEntities; _i < newEntities_2.length; _i++){\n            var entity = newEntities_2[_i];\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_3 = newEntities; _i < newEntities_3.length; _i++){\n            var entity = newEntities_3[_i];\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        var didMutate = false;\n        keys.forEach(function(key) {\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter(function(id) {\n                return id in state.entities;\n            });\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        var original2 = state.entities[update.id];\n        var updated = Object.assign({}, original2, update.changes);\n        var newKey = selectIdValue(updated, selectId);\n        var hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        var newKeys = {};\n        var updatesPerEntity = {};\n        updates.forEach(function(update) {\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    changes: __spreadValues(__spreadValues({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        var didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            var didMutateIds = updates.filter(function(update) {\n                return takeNewKey(newKeys, update, state);\n            }).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.keys(state.entities);\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    var _c = createUnsortedStateAdapter(selectId), removeOne = _c.removeOne, removeMany = _c.removeMany, removeAll = _c.removeAll;\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        var models = newEntities.filter(function(model) {\n            return !(selectIdValue(model, selectId) in state.entities);\n        });\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        var appliedUpdates = false;\n        for(var _i = 0, updates_1 = updates; _i < updates_1.length; _i++){\n            var update = updates_1[_i];\n            var entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            var newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(var i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach(function(model) {\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        var allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        var newSortedIds = allEntities.map(selectId);\n        var ids = state.ids;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne: removeOne,\n        removeMany: removeMany,\n        removeAll: removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = __spreadValues({\n        sortComparer: false,\n        selectId: function(instance) {\n            return instance.id;\n        }\n    }, options), selectId = _c.selectId, sortComparer = _c.sortComparer;\n    var stateFactory = createInitialStateFactory();\n    var selectorsFactory = createSelectorsFactory();\n    var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    return __spreadValues(__spreadValues(__spreadValues({\n        selectId: selectId,\n        sortComparer: sortComparer\n    }, stateFactory), selectorsFactory), stateAdapter);\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = function(size) {\n    if (size === void 0) {\n        size = 21;\n    }\n    var id = \"\";\n    var i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = /** @class */ function() {\n    function RejectWithValue(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return RejectWithValue;\n}();\nvar FulfillWithMeta = /** @class */ function() {\n    function FulfillWithMeta(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return FulfillWithMeta;\n}();\nvar miniSerializeError = function(value) {\n    if (typeof value === \"object\" && value !== null) {\n        var simpleError = {};\n        for(var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++){\n            var property = commonProperties_1[_i];\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = function() {\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        var fulfilled = createAction(typePrefix + \"/fulfilled\", function(payload, requestId, arg, meta) {\n            return {\n                payload: payload,\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    requestStatus: \"fulfilled\"\n                })\n            };\n        });\n        var pending = createAction(typePrefix + \"/pending\", function(requestId, arg, meta) {\n            return {\n                payload: void 0,\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    requestStatus: \"pending\"\n                })\n            };\n        });\n        var rejected = createAction(typePrefix + \"/rejected\", function(error, requestId, arg, payload, meta) {\n            return {\n                payload: payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: (error == null ? void 0 : error.name) === \"AbortError\",\n                    condition: (error == null ? void 0 : error.name) === \"ConditionError\"\n                })\n            };\n        });\n        var displayedWarning = false;\n        var AC = typeof AbortController !== \"undefined\" ? AbortController : /** @class */ function() {\n            function class_1() {\n                this.signal = {\n                    aborted: false,\n                    addEventListener: function() {},\n                    dispatchEvent: function() {\n                        return false;\n                    },\n                    onabort: function() {},\n                    removeEventListener: function() {},\n                    reason: void 0,\n                    throwIfAborted: function() {}\n                };\n            }\n            class_1.prototype.abort = function() {\n                if (true) {\n                    if (!displayedWarning) {\n                        displayedWarning = true;\n                        console.info(\"This platform does not implement AbortController. \\nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.\");\n                    }\n                }\n            };\n            return class_1;\n        }();\n        function actionCreator(arg) {\n            return function(dispatch, getState, extra) {\n                var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();\n                var abortController = new AC();\n                var abortReason;\n                var started = false;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                var promise2 = function() {\n                    return __async(this, null, function() {\n                        var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;\n                        return __generator(this, function(_c) {\n                            switch(_c.label){\n                                case 0:\n                                    _c.trys.push([\n                                        0,\n                                        4,\n                                        ,\n                                        5\n                                    ]);\n                                    conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {\n                                        getState: getState,\n                                        extra: extra\n                                    });\n                                    if (!isThenable(conditionResult)) return [\n                                        3 /*break*/ ,\n                                        2\n                                    ];\n                                    return [\n                                        4 /*yield*/ ,\n                                        conditionResult\n                                    ];\n                                case 1:\n                                    conditionResult = _c.sent();\n                                    _c.label = 2;\n                                case 2:\n                                    if (conditionResult === false || abortController.signal.aborted) {\n                                        throw {\n                                            name: \"ConditionError\",\n                                            message: \"Aborted due to condition callback returning false.\"\n                                        };\n                                    }\n                                    started = true;\n                                    abortedPromise = new Promise(function(_, reject) {\n                                        return abortController.signal.addEventListener(\"abort\", function() {\n                                            return reject({\n                                                name: \"AbortError\",\n                                                message: abortReason || \"Aborted\"\n                                            });\n                                        });\n                                    });\n                                    dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {\n                                        requestId: requestId,\n                                        arg: arg\n                                    }, {\n                                        getState: getState,\n                                        extra: extra\n                                    })));\n                                    return [\n                                        4 /*yield*/ ,\n                                        Promise.race([\n                                            abortedPromise,\n                                            Promise.resolve(payloadCreator(arg, {\n                                                dispatch: dispatch,\n                                                getState: getState,\n                                                extra: extra,\n                                                requestId: requestId,\n                                                signal: abortController.signal,\n                                                abort: abort,\n                                                rejectWithValue: function(value, meta) {\n                                                    return new RejectWithValue(value, meta);\n                                                },\n                                                fulfillWithValue: function(value, meta) {\n                                                    return new FulfillWithMeta(value, meta);\n                                                }\n                                            })).then(function(result) {\n                                                if (result instanceof RejectWithValue) {\n                                                    throw result;\n                                                }\n                                                if (result instanceof FulfillWithMeta) {\n                                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                                }\n                                                return fulfilled(result, requestId, arg);\n                                            })\n                                        ])\n                                    ];\n                                case 3:\n                                    finalAction = _c.sent();\n                                    return [\n                                        3 /*break*/ ,\n                                        5\n                                    ];\n                                case 4:\n                                    err_1 = _c.sent();\n                                    finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);\n                                    return [\n                                        3 /*break*/ ,\n                                        5\n                                    ];\n                                case 5:\n                                    skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                                    if (!skipDispatch) {\n                                        dispatch(finalAction);\n                                    }\n                                    return [\n                                        2 /*return*/ ,\n                                        finalAction\n                                    ];\n                            }\n                        });\n                    });\n                }();\n                return Object.assign(promise2, {\n                    abort: abort,\n                    requestId: requestId,\n                    arg: arg,\n                    unwrap: function() {\n                        return promise2.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending: pending,\n            rejected: rejected,\n            fulfilled: fulfilled,\n            typePrefix: typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = function() {\n        return createAsyncThunk2;\n    };\n    return createAsyncThunk2;\n}();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/tsHelpers.ts\nvar hasMatchFunction = function(v) {\n    return v && typeof v.match === \"function\";\n};\n// src/matchers.ts\nvar matches = function(matcher, action) {\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.some(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction isAllOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.every(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    var hasValidRequestId = typeof action.meta.requestId === \"string\";\n    var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.pending;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.rejected;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    var hasFlag = function(action) {\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return function(action) {\n        var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.fulfilled;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = [];\n        for(var _i = 0, asyncThunks_1 = asyncThunks; _i < asyncThunks_1.length; _i++){\n            var asyncThunk = asyncThunks_1[_i];\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/listenerMiddleware/utils.ts\nvar assertFunction = function(func, expected) {\n    if (typeof func !== \"function\") {\n        throw new TypeError(expected + \" is not a function\");\n    }\n};\nvar noop = function() {};\nvar catchRejection = function(promise2, onError) {\n    if (onError === void 0) {\n        onError = noop;\n    }\n    promise2.catch(onError);\n    return promise2;\n};\nvar addAbortSignalListener = function(abortSignal, callback) {\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return function() {\n        return abortSignal.removeEventListener(\"abort\", callback);\n    };\n};\nvar abortControllerWithReason = function(abortController, reason) {\n    var signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = \"task-\" + cancelled;\nvar taskCompleted = \"task-\" + completed;\nvar listenerCancelled = listener + \"-\" + cancelled;\nvar listenerCompleted = listener + \"-\" + completed;\nvar TaskAbortError = /** @class */ function() {\n    function TaskAbortError(code) {\n        this.code = code;\n        this.name = \"TaskAbortError\";\n        this.message = task + \" \" + cancelled + \" (reason: \" + code + \")\";\n    }\n    return TaskAbortError;\n}();\n// src/listenerMiddleware/task.ts\nvar validateActive = function(signal) {\n    if (signal.aborted) {\n        throw new TaskAbortError(signal.reason);\n    }\n};\nfunction raceWithSignal(signal, promise2) {\n    var cleanup = noop;\n    return new Promise(function(resolve, reject) {\n        var notifyRejection = function() {\n            return reject(new TaskAbortError(signal.reason));\n        };\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise2.finally(function() {\n            return cleanup();\n        }).then(resolve, reject);\n    }).finally(function() {\n        cleanup = noop;\n    });\n}\nvar runTask = function(task2, cleanUp) {\n    return __async(void 0, null, function() {\n        var value, error_1;\n        return __generator(this, function(_c) {\n            switch(_c.label){\n                case 0:\n                    _c.trys.push([\n                        0,\n                        3,\n                        4,\n                        5\n                    ]);\n                    return [\n                        4 /*yield*/ ,\n                        Promise.resolve()\n                    ];\n                case 1:\n                    _c.sent();\n                    return [\n                        4 /*yield*/ ,\n                        task2()\n                    ];\n                case 2:\n                    value = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: \"ok\",\n                            value: value\n                        }\n                    ];\n                case 3:\n                    error_1 = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: error_1 instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n                            error: error_1\n                        }\n                    ];\n                case 4:\n                    cleanUp == null ? void 0 : cleanUp();\n                    return [\n                        7 /*endfinally*/ \n                    ];\n                case 5:\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n};\nvar createPause = function(signal) {\n    return function(promise2) {\n        return catchRejection(raceWithSignal(signal, promise2).then(function(output) {\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = function(signal) {\n    var pause = createPause(signal);\n    return function(timeoutMs) {\n        return pause(new Promise(function(resolve) {\n            return setTimeout(resolve, timeoutMs);\n        }));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar assign = Object.assign;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = function(parentAbortSignal) {\n    var linkControllers = function(controller) {\n        return addAbortSignalListener(parentAbortSignal, function() {\n            return abortControllerWithReason(controller, parentAbortSignal.reason);\n        });\n    };\n    return function(taskExecutor) {\n        assertFunction(taskExecutor, \"taskExecutor\");\n        var childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        var result = runTask(function() {\n            return __async(void 0, null, function() {\n                var result2;\n                return __generator(this, function(_c) {\n                    switch(_c.label){\n                        case 0:\n                            validateActive(parentAbortSignal);\n                            validateActive(childAbortController.signal);\n                            return [\n                                4 /*yield*/ ,\n                                taskExecutor({\n                                    pause: createPause(childAbortController.signal),\n                                    delay: createDelay(childAbortController.signal),\n                                    signal: childAbortController.signal\n                                })\n                            ];\n                        case 1:\n                            result2 = _c.sent();\n                            validateActive(childAbortController.signal);\n                            return [\n                                2 /*return*/ ,\n                                result2\n                            ];\n                    }\n                });\n            });\n        }, function() {\n            return abortControllerWithReason(childAbortController, taskCompleted);\n        });\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel: function() {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = function(startListening, signal) {\n    var take = function(predicate, timeout) {\n        return __async(void 0, null, function() {\n            var unsubscribe, tuplePromise, promises, output;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        validateActive(signal);\n                        unsubscribe = function() {};\n                        tuplePromise = new Promise(function(resolve, reject) {\n                            var stopListening = startListening({\n                                predicate: predicate,\n                                effect: function(action, listenerApi) {\n                                    listenerApi.unsubscribe();\n                                    resolve([\n                                        action,\n                                        listenerApi.getState(),\n                                        listenerApi.getOriginalState()\n                                    ]);\n                                }\n                            });\n                            unsubscribe = function() {\n                                stopListening();\n                                reject();\n                            };\n                        });\n                        promises = [\n                            tuplePromise\n                        ];\n                        if (timeout != null) {\n                            promises.push(new Promise(function(resolve) {\n                                return setTimeout(resolve, timeout, null);\n                            }));\n                        }\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            ,\n                            3,\n                            4\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            raceWithSignal(signal, Promise.race(promises))\n                        ];\n                    case 2:\n                        output = _c.sent();\n                        validateActive(signal);\n                        return [\n                            2 /*return*/ ,\n                            output\n                        ];\n                    case 3:\n                        unsubscribe();\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 4:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return function(predicate, timeout) {\n        return catchRejection(take(predicate, timeout));\n    };\n};\nvar getListenerEntryPropsFrom = function(options) {\n    var type = options.type, actionCreator = options.actionCreator, matcher = options.matcher, predicate = options.predicate, effect = options.effect;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error(\"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate: predicate,\n        type: type,\n        effect: effect\n    };\n};\nvar createListenerEntry = function(options) {\n    var _c = getListenerEntryPropsFrom(options), type = _c.type, predicate = _c.predicate, effect = _c.effect;\n    var id = nanoid();\n    var entry = {\n        id: id,\n        effect: effect,\n        type: type,\n        predicate: predicate,\n        pending: new Set(),\n        unsubscribe: function() {\n            throw new Error(\"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n};\nvar cancelActiveListeners = function(entry) {\n    entry.pending.forEach(function(controller) {\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = function(listenerMap) {\n    return function() {\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = function(errorHandler, errorToNotify, errorInfo) {\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(function() {\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = createAction(alm + \"/add\");\nvar clearAllListeners = createAction(alm + \"/removeAll\");\nvar removeListener = createAction(alm + \"/remove\");\nvar defaultErrorHandler = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    console.error.apply(console, __spreadArray([\n        alm + \"/error\"\n    ], args));\n};\nfunction createListenerMiddleware(middlewareOptions) {\n    var _this = this;\n    if (middlewareOptions === void 0) {\n        middlewareOptions = {};\n    }\n    var listenerMap = new Map();\n    var extra = middlewareOptions.extra, _c = middlewareOptions.onError, onError = _c === void 0 ? defaultErrorHandler : _c;\n    assertFunction(onError, \"onError\");\n    var insertEntry = function(entry) {\n        entry.unsubscribe = function() {\n            return listenerMap.delete(entry.id);\n        };\n        listenerMap.set(entry.id, entry);\n        return function(cancelOptions) {\n            entry.unsubscribe();\n            if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    var findListenerEntry = function(comparator) {\n        for(var _i = 0, _c = Array.from(listenerMap.values()); _i < _c.length; _i++){\n            var entry = _c[_i];\n            if (comparator(entry)) {\n                return entry;\n            }\n        }\n        return void 0;\n    };\n    var startListening = function(options) {\n        var entry = findListenerEntry(function(existingEntry) {\n            return existingEntry.effect === options.effect;\n        });\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    var stopListening = function(options) {\n        var _c = getListenerEntryPropsFrom(options), type = _c.type, effect = _c.effect, predicate = _c.predicate;\n        var entry = findListenerEntry(function(entry2) {\n            var matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    var notifyListener = function(entry, action, api, getOriginalState) {\n        return __async(_this, null, function() {\n            var internalTaskController, take, listenerError_1;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        internalTaskController = new AbortController();\n                        take = createTakePattern(startListening, internalTaskController.signal);\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            3,\n                            4,\n                            5\n                        ]);\n                        entry.pending.add(internalTaskController);\n                        return [\n                            4 /*yield*/ ,\n                            Promise.resolve(entry.effect(action, assign({}, api, {\n                                getOriginalState: getOriginalState,\n                                condition: function(predicate, timeout) {\n                                    return take(predicate, timeout).then(Boolean);\n                                },\n                                take: take,\n                                delay: createDelay(internalTaskController.signal),\n                                pause: createPause(internalTaskController.signal),\n                                extra: extra,\n                                signal: internalTaskController.signal,\n                                fork: createFork(internalTaskController.signal),\n                                unsubscribe: entry.unsubscribe,\n                                subscribe: function() {\n                                    listenerMap.set(entry.id, entry);\n                                },\n                                cancelActiveListeners: function() {\n                                    entry.pending.forEach(function(controller, _, set) {\n                                        if (controller !== internalTaskController) {\n                                            abortControllerWithReason(controller, listenerCancelled);\n                                            set.delete(controller);\n                                        }\n                                    });\n                                }\n                            })))\n                        ];\n                    case 2:\n                        _c.sent();\n                        return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                    case 3:\n                        listenerError_1 = _c.sent();\n                        if (!(listenerError_1 instanceof TaskAbortError)) {\n                            safelyNotifyError(onError, listenerError_1, {\n                                raisedBy: \"effect\"\n                            });\n                        }\n                        return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                    case 4:\n                        abortControllerWithReason(internalTaskController, listenerCompleted);\n                        entry.pending.delete(internalTaskController);\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 5:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    var clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    var middleware = function(api) {\n        return function(next) {\n            return function(action) {\n                if (!isAction(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                var originalState = api.getState();\n                var getOriginalState = function() {\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error(alm + \": getOriginalState can only be called synchronously\");\n                    }\n                    return originalState;\n                };\n                var result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        var currentState = api.getState();\n                        var listenerEntries = Array.from(listenerMap.values());\n                        for(var _i = 0, listenerEntries_1 = listenerEntries; _i < listenerEntries_1.length; _i++){\n                            var entry = listenerEntries_1[_i];\n                            var runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n        };\n    };\n    return {\n        middleware: middleware,\n        startListening: startListening,\n        stopListening: stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n}\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = function() {\n    return function(payload) {\n        var _c;\n        return {\n            payload: payload,\n            meta: (_c = {}, _c[SHOULD_AUTOBATCH] = true, _c)\n        };\n    };\n};\nvar promise;\nvar queueMicrotaskShim = typeof queueMicrotask === \"function\" ? queueMicrotask.bind( false ? 0 : typeof global !== \"undefined\" ? global : globalThis) : function(cb) {\n    return (promise || (promise = Promise.resolve())).then(cb).catch(function(err) {\n        return setTimeout(function() {\n            throw err;\n        }, 0);\n    });\n};\nvar createQueueWithTimer = function(timeout) {\n    return function(notify) {\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  false ? 0 : createQueueWithTimer(10);\nvar autoBatchEnhancer = function(options) {\n    if (options === void 0) {\n        options = {\n            type: \"raf\"\n        };\n    }\n    return function(next) {\n        return function() {\n            var args = [];\n            for(var _i = 0; _i < arguments.length; _i++){\n                args[_i] = arguments[_i];\n            }\n            var store = next.apply(void 0, args);\n            var notifying = true;\n            var shouldNotifyAtEndOfTick = false;\n            var notificationQueued = false;\n            var listeners = new Set();\n            var queueCallback = options.type === \"tick\" ? queueMicrotaskShim : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            var notifyListeners = function() {\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach(function(l) {\n                        return l();\n                    });\n                }\n            };\n            return Object.assign({}, store, {\n                subscribe: function(listener2) {\n                    var wrappedListener = function() {\n                        return notifying && listener2();\n                    };\n                    var unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return function() {\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                dispatch: function(action) {\n                    var _a;\n                    try {\n                        notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n    };\n};\n// src/index.ts\n(0,immer__WEBPACK_IMPORTED_MODULE_2__.enableES5)();\n //# sourceMappingURL=redux-toolkit.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLO0lBQ3hDLElBQUlDLGdCQUFnQixTQUFVQyxDQUFDLEVBQUVDLENBQUM7UUFDOUJGLGdCQUFnQkcsT0FBT0MsY0FBYyxJQUNoQztZQUFFQyxXQUFXLEVBQUU7UUFBQyxjQUFhQyxTQUFTLFNBQVVMLENBQUMsRUFBRUMsQ0FBQztZQUFJRCxFQUFFSSxTQUFTLEdBQUdIO1FBQUcsS0FDMUUsU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1lBQUksSUFBSyxJQUFJSyxLQUFLTCxFQUFHLElBQUlDLE9BQU9LLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLElBQUlOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7UUFBRTtRQUNwRyxPQUFPUCxjQUFjQyxHQUFHQztJQUM1QjtJQUNBLE9BQU8sU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1FBQ2pCLElBQUksT0FBT0EsTUFBTSxjQUFjQSxNQUFNLE1BQ2pDLE1BQU0sSUFBSVMsVUFBVSx5QkFBeUJDLE9BQU9WLEtBQUs7UUFDN0RGLGNBQWNDLEdBQUdDO1FBQ2pCLFNBQVNXO1lBQU8sSUFBSSxDQUFDQyxXQUFXLEdBQUdiO1FBQUc7UUFDdENBLEVBQUVPLFNBQVMsR0FBR04sTUFBTSxPQUFPQyxPQUFPWSxNQUFNLENBQUNiLEtBQU1XLENBQUFBLEdBQUdMLFNBQVMsR0FBR04sRUFBRU0sU0FBUyxFQUFFLElBQUlLLElBQUc7SUFDdEY7QUFDSjtBQUNBLElBQUlHLGNBQWMsU0FBSyxJQUFJLFNBQUksQ0FBQ0EsV0FBVyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsSUFBSTtJ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Q3pCLElBQUksQ0FBQ0Msb0JBQW9CO2dDQUNyQkEscUJBQXFCO2dDQUNyQkUsY0FBY0U7NEJBQ2xCO3dCQUNKO3dCQUNBLE9BQU9QLE1BQU1uSyxRQUFRLENBQUM1UTtvQkFDMUIsU0FDUTt3QkFDSmdiLFlBQVk7b0JBQ2hCO2dCQUNKO1lBQ0o7UUFDSjtJQUFHO0FBQ1A7QUFDQSxlQUFlO0FBQ2ZuaUIsZ0RBQVNBO0FBQ3N4QixDQUMveEIsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0LmVzbS5qcz84Y2NjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxyXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcclxuICAgIHJldHVybiB0bztcclxufTtcclxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcclxudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcclxudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XHJcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcclxudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xyXG52YXIgX19kZWZOb3JtYWxQcm9wID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlOyB9O1xyXG52YXIgX19zcHJlYWRWYWx1ZXMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxyXG4gICAgICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcclxuICAgICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xyXG4gICAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IF9fZ2V0T3duUHJvcFN5bWJvbHMoYik7IF9pIDwgX2MubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wID0gX2NbX2ldO1xyXG4gICAgICAgICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXHJcbiAgICAgICAgICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn07XHJcbnZhciBfX3NwcmVhZFByb3BzID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpOyB9O1xyXG52YXIgX19hc3luYyA9IGZ1bmN0aW9uIChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIGZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH07XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbi8vIHNyYy9pbmRleC50c1xyXG5pbXBvcnQgeyBlbmFibGVFUzUgfSBmcm9tIFwiaW1tZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcInJlZHV4XCI7XHJcbmltcG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdDIsIGN1cnJlbnQgYXMgY3VycmVudDIsIGZyZWV6ZSwgb3JpZ2luYWwsIGlzRHJhZnQgYXMgaXNEcmFmdDQgfSBmcm9tIFwiaW1tZXJcIjtcclxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgYXMgY3JlYXRlU2VsZWN0b3IyIH0gZnJvbSBcInJlc2VsZWN0XCI7XHJcbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xyXG5pbXBvcnQgeyBjdXJyZW50LCBpc0RyYWZ0IH0gZnJvbSBcImltbWVyXCI7XHJcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0XCI7XHJcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgYXJncyk7XHJcbiAgICB2YXIgd3JhcHBlZFNlbGVjdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJlc3QgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICByZXN0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZWN0b3IuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWVdLCByZXN0KSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcclxufTtcclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbmltcG9ydCB7IGNyZWF0ZVN0b3JlLCBjb21wb3NlIGFzIGNvbXBvc2UyLCBhcHBseU1pZGRsZXdhcmUsIGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xyXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcclxuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gXCJyZWR1eFwiO1xyXG52YXIgY29tcG9zZVdpdGhEZXZUb29scyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2U7XHJcbiAgICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG52YXIgZGV2VG9vbHNFbmhhbmNlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobm9vcDIpIHtcclxuICAgICAgICByZXR1cm4gbm9vcDI7XHJcbiAgICB9O1xyXG59O1xyXG4vLyBzcmMvaXNQbGFpbk9iamVjdC50c1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XHJcbiAgICBpZiAocHJvdG8gPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB2YXIgYmFzZVByb3RvID0gcHJvdG87XHJcbiAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcclxuICAgICAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm90byA9PT0gYmFzZVByb3RvO1xyXG59XHJcbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xyXG5pbXBvcnQgdGh1bmtNaWRkbGV3YXJlIGZyb20gXCJyZWR1eC10aHVua1wiO1xyXG4vLyBzcmMvdXRpbHMudHNcclxuaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZSwgeyBpc0RyYWZ0YWJsZSB9IGZyb20gXCJpbW1lclwiO1xyXG5mdW5jdGlvbiBnZXRUaW1lTWVhc3VyZVV0aWxzKG1heERlbGF5LCBmbk5hbWUpIHtcclxuICAgIHZhciBlbGFwc2VkID0gMDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWVhc3VyZVRpbWU6IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBlbGFwc2VkICs9IGZpbmlzaGVkIC0gc3RhcnRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2FybklmRXhjZWVkZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGZuTmFtZSArIFwiIHRvb2sgXCIgKyBlbGFwc2VkICsgXCJtcywgd2hpY2ggaXMgbW9yZSB0aGFuIHRoZSB3YXJuaW5nIHRocmVzaG9sZCBvZiBcIiArIG1heERlbGF5ICsgXCJtcy4gXFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxcbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxudmFyIE1pZGRsZXdhcmVBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNaWRkbGV3YXJlQXJyYXksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNaWRkbGV3YXJlQXJyYXkoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmdzKSB8fCB0aGlzO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWlkZGxld2FyZUFycmF5LnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pZGRsZXdhcmVBcnJheSwgU3ltYm9sLnNwZWNpZXMsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1pZGRsZXdhcmVBcnJheTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNaWRkbGV3YXJlQXJyYXkucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xyXG4gICAgfTtcclxuICAgIE1pZGRsZXdhcmVBcnJheS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IChNaWRkbGV3YXJlQXJyYXkuYmluZC5hcHBseShNaWRkbGV3YXJlQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyclswXS5jb25jYXQodGhpcykpKSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoTWlkZGxld2FyZUFycmF5LmJpbmQuYXBwbHkoTWlkZGxld2FyZUFycmF5LCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCBhcnIuY29uY2F0KHRoaXMpKSkpKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1pZGRsZXdhcmVBcnJheTtcclxufShBcnJheSkpO1xyXG52YXIgRW5oYW5jZXJBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFbmhhbmNlckFycmF5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW5oYW5jZXJBcnJheSgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpIHx8IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBFbmhhbmNlckFycmF5LnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuaGFuY2VyQXJyYXksIFN5bWJvbC5zcGVjaWVzLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbmhhbmNlckFycmF5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEVuaGFuY2VyQXJyYXkucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xyXG4gICAgfTtcclxuICAgIEVuaGFuY2VyQXJyYXkucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFycltfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyclswXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoRW5oYW5jZXJBcnJheS5iaW5kLmFwcGx5KEVuaGFuY2VyQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyclswXS5jb25jYXQodGhpcykpKSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoRW5oYW5jZXJBcnJheS5iaW5kLmFwcGx5KEVuaGFuY2VyQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyci5jb25jYXQodGhpcykpKSkoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW5oYW5jZXJBcnJheTtcclxufShBcnJheSkpO1xyXG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XHJcbiAgICByZXR1cm4gaXNEcmFmdGFibGUodmFsKSA/IGNyZWF0ZU5leHRTdGF0ZSh2YWwsIGZ1bmN0aW9uICgpIHtcclxuICAgIH0pIDogdmFsO1xyXG59XHJcbi8vIHNyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxudmFyIHByZWZpeCA9IFwiSW52YXJpYW50IGZhaWxlZFwiO1xyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8IFwiXCIpKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBzZXJpYWxpemVyLCBpbmRlbnQsIGRlY3ljbGVyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZShzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xyXG4gICAgdmFyIHN0YWNrID0gW10sIGtleXMgPSBbXTtcclxuICAgIGlmICghZGVjeWNsZXIpXHJcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbiAoXywgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+XVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09IG51bGwgfHwgT2JqZWN0LmlzRnJvemVuKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiB0cmFja0Zvck11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaikge1xyXG4gICAgdmFyIHRyYWNrZWRQcm9wZXJ0aWVzID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGV0ZWN0TXV0YXRpb25zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaiwgcGF0aCkge1xyXG4gICAgaWYgKGlnbm9yZVBhdGhzID09PSB2b2lkIDApIHsgaWdub3JlUGF0aHMgPSBbXTsgfVxyXG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxyXG4gICAgdmFyIHRyYWNrZWQgPSB7IHZhbHVlOiBvYmogfTtcclxuICAgIGlmICghaXNJbW11dGFibGUob2JqKSkge1xyXG4gICAgICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cmFja2VkO1xyXG59XHJcbmZ1bmN0aW9uIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiwgcGF0aCkge1xyXG4gICAgaWYgKGlnbm9yZWRQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZWRQYXRocyA9IFtdOyB9XHJcbiAgICBpZiAoc2FtZVBhcmVudFJlZiA9PT0gdm9pZCAwKSB7IHNhbWVQYXJlbnRSZWYgPSBmYWxzZTsgfVxyXG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxyXG4gICAgdmFyIHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB2b2lkIDA7XHJcbiAgICB2YXIgc2FtZVJlZiA9IHByZXZPYmogPT09IG9iajtcclxuICAgIGlmIChzYW1lUGFyZW50UmVmICYmICFzYW1lUmVmICYmICFOdW1iZXIuaXNOYU4ob2JqKSkge1xyXG4gICAgICAgIHJldHVybiB7IHdhc011dGF0ZWQ6IHRydWUsIHBhdGg6IHBhdGggfTtcclxuICAgIH1cclxuICAgIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2FzTXV0YXRlZDogZmFsc2UgfTtcclxuICAgIH1cclxuICAgIHZhciBrZXlzVG9EZXRlY3QgPSB7fTtcclxuICAgIGZvciAodmFyIGtleSBpbiB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW4pIHtcclxuICAgICAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xyXG4gICAgICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcclxuICAgICAgICAgICAgdmFyIGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZShmdW5jdGlvbiAoaWdub3JlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaGFzTWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbltrZXldLCBvYmpba2V5XSwgc2FtZVJlZiwgbmVzdGVkUGF0aCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIGtleXNUb0RldGVjdCkge1xyXG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMShrZXkpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB3YXNNdXRhdGVkOiBmYWxzZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV4dChhY3Rpb24pOyB9OyB9OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy5pc0ltbXV0YWJsZSwgaXNJbW11dGFibGUgPSBfYyA9PT0gdm9pZCAwID8gaXNJbW11dGFibGVEZWZhdWx0IDogX2MsIGlnbm9yZWRQYXRocyA9IG9wdGlvbnMuaWdub3JlZFBhdGhzLCBfZCA9IG9wdGlvbnMud2FybkFmdGVyLCB3YXJuQWZ0ZXIgPSBfZCA9PT0gdm9pZCAwID8gMzIgOiBfZCwgaWdub3JlID0gb3B0aW9ucy5pZ25vcmU7XHJcbiAgICBpZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMgfHwgaWdub3JlO1xyXG4gICAgdmFyIHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICB2YXIgZ2V0U3RhdGUgPSBfYy5nZXRTdGF0ZTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIGludmFyaWFudCghcmVzdWx0Lndhc011dGF0ZWQsIFwiQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgYmV0d2VlbiBkaXNwYXRjaGVzLCBpbiB0aGUgcGF0aCAnXCIgKyAocmVzdWx0LnBhdGggfHwgXCJcIikgKyBcIicuICBUaGlzIG1heSBjYXVzZSBpbmNvcnJlY3QgYmVoYXZpb3IuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQud2FzTXV0YXRlZCAmJiBpbnZhcmlhbnQoIXJlc3VsdC53YXNNdXRhdGVkLCBcIkEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGluc2lkZSBhIGRpc3BhdGNoLCBpbiB0aGUgcGF0aDogXCIgKyAocmVzdWx0LnBhdGggfHwgXCJcIikgKyBcIi4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiBcIiArIHN0cmluZ2lmeShhY3Rpb24pICsgXCIuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hlZEFjdGlvbjtcclxuICAgICAgICB9OyB9O1xyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzUGxhaW4odmFsKSB7XHJcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XHJcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSB8fCBpc1BsYWluT2JqZWN0KHZhbCk7XHJcbn1cclxuZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlLCBwYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSkge1xyXG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxyXG4gICAgaWYgKGlzU2VyaWFsaXphYmxlID09PSB2b2lkIDApIHsgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluOyB9XHJcbiAgICBpZiAoaWdub3JlZFBhdGhzID09PSB2b2lkIDApIHsgaWdub3JlZFBhdGhzID0gW107IH1cclxuICAgIHZhciBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcclxuICAgIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGUuaGFzKHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoa2V5LCBuZXN0ZWRWYWx1ZSkge1xyXG4gICAgICAgIHZhciBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcclxuICAgICAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGhhc01hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiBuZXN0ZWRQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5lc3RlZFZhbHVlLCBuZXN0ZWRQYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfaSA8IGVudHJpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgX2MgPSBlbnRyaWVzXzFbX2ldLCBrZXkgPSBfY1swXSwgbmVzdGVkVmFsdWUgPSBfY1sxXTtcclxuICAgICAgICB2YXIgc3RhdGVfMiA9IF9sb29wXzIoa2V5LCBuZXN0ZWRWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8yID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGVfMi52YWx1ZTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpXHJcbiAgICAgICAgY2FjaGUuYWRkKHZhbHVlKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xyXG4gICAgaWYgKCFPYmplY3QuaXNGcm96ZW4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBPYmplY3QudmFsdWVzKHZhbHVlKTsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgbmVzdGVkVmFsdWUgPSBfY1tfaV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKCFpc05lc3RlZEZyb3plbihuZXN0ZWRWYWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV4dChhY3Rpb24pOyB9OyB9OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy5pc1NlcmlhbGl6YWJsZSwgaXNTZXJpYWxpemFibGUgPSBfYyA9PT0gdm9pZCAwID8gaXNQbGFpbiA6IF9jLCBnZXRFbnRyaWVzID0gb3B0aW9ucy5nZXRFbnRyaWVzLCBfZCA9IG9wdGlvbnMuaWdub3JlZEFjdGlvbnMsIGlnbm9yZWRBY3Rpb25zID0gX2QgPT09IHZvaWQgMCA/IFtdIDogX2QsIF9lID0gb3B0aW9ucy5pZ25vcmVkQWN0aW9uUGF0aHMsIGlnbm9yZWRBY3Rpb25QYXRocyA9IF9lID09PSB2b2lkIDAgPyBbXCJtZXRhLmFyZ1wiLCBcIm1ldGEuYmFzZVF1ZXJ5TWV0YVwiXSA6IF9lLCBfZiA9IG9wdGlvbnMuaWdub3JlZFBhdGhzLCBpZ25vcmVkUGF0aHMgPSBfZiA9PT0gdm9pZCAwID8gW10gOiBfZiwgX2cgPSBvcHRpb25zLndhcm5BZnRlciwgd2FybkFmdGVyID0gX2cgPT09IHZvaWQgMCA/IDMyIDogX2csIF9oID0gb3B0aW9ucy5pZ25vcmVTdGF0ZSwgaWdub3JlU3RhdGUgPSBfaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaCwgX2ogPSBvcHRpb25zLmlnbm9yZUFjdGlvbnMsIGlnbm9yZUFjdGlvbnMgPSBfaiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaiwgX2sgPSBvcHRpb25zLmRpc2FibGVDYWNoZSwgZGlzYWJsZUNhY2hlID0gX2sgPT09IHZvaWQgMCA/IGZhbHNlIDogX2s7XHJcbiAgICB2YXIgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyBuZXcgV2Vha1NldCgpIDogdm9pZCAwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZUFQSSkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIGFuIGFjdGlvbiwgaW4gdGhlIHBhdGg6IGBcIiArIGtleVBhdGggKyBcImAuIFZhbHVlOlwiLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiBcIiwgYWN0aW9uLCBcIlxcbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL2FjdGlvbnMjd2h5LXNob3VsZC10eXBlLWJlLWEtc3RyaW5nLW9yLWF0LWxlYXN0LXNlcmlhbGl6YWJsZS13aHktc2hvdWxkLW15LWFjdGlvbi10eXBlcy1iZS1jb25zdGFudHMpXCIsIFwiXFxuKFRvIGFsbG93IG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIHNlZTogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy91c2FnZS91c2FnZS1ndWlkZSN3b3JraW5nLXdpdGgtbm9uLXNlcmlhbGl6YWJsZS1kYXRhKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogYFwiICsga2V5UGF0aCArIFwiYC4gVmFsdWU6XCIsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6IFwiICsgYWN0aW9uLnR5cGUgKyBcIi5cXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07IH07IH07XHJcbn1cclxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xyXG59XHJcbmZ1bmN0aW9uIGN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmUoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucyk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICB2YXIgX2MgPSBvcHRpb25zLnRodW5rLCB0aHVuayA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5pbW11dGFibGVDaGVjaywgaW1tdXRhYmxlQ2hlY2sgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBfZSA9IG9wdGlvbnMuc2VyaWFsaXphYmxlQ2hlY2ssIHNlcmlhbGl6YWJsZUNoZWNrID0gX2UgPT09IHZvaWQgMCA/IHRydWUgOiBfZTtcclxuICAgIHZhciBtaWRkbGV3YXJlQXJyYXkgPSBuZXcgTWlkZGxld2FyZUFycmF5KCk7XHJcbiAgICBpZiAodGh1bmspIHtcclxuICAgICAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlLndpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKGltbXV0YWJsZUNoZWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbW11dGFibGVPcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xyXG4gICAgICAgICAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShpbW11dGFibGVPcHRpb25zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXJpYWxpemFibGVDaGVjaykge1xyXG4gICAgICAgICAgICB2YXIgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaChjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoc2VyaWFsaXphYmxlT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XHJcbn1cclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbnZhciBJU19QUk9EVUNUSU9OID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xyXG5mdW5jdGlvbiBjb25maWd1cmVTdG9yZShvcHRpb25zKSB7XHJcbiAgICB2YXIgY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlID0gY3VycnlHZXREZWZhdWx0TWlkZGxld2FyZSgpO1xyXG4gICAgdmFyIF9jID0gb3B0aW9ucyB8fCB7fSwgX2QgPSBfYy5yZWR1Y2VyLCByZWR1Y2VyID0gX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLCBfZSA9IF9jLm1pZGRsZXdhcmUsIG1pZGRsZXdhcmUgPSBfZSA9PT0gdm9pZCAwID8gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKCkgOiBfZSwgX2YgPSBfYy5kZXZUb29scywgZGV2VG9vbHMgPSBfZiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9mLCBfZyA9IF9jLnByZWxvYWRlZFN0YXRlLCBwcmVsb2FkZWRTdGF0ZSA9IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZywgX2ggPSBfYy5lbmhhbmNlcnMsIGVuaGFuY2VycyA9IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaDtcclxuICAgIHZhciByb290UmVkdWNlcjtcclxuICAgIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChyZWR1Y2VyKSkge1xyXG4gICAgICAgIHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHJlZHVjZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInJlZHVjZXJcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2VycycpO1xyXG4gICAgfVxyXG4gICAgdmFyIGZpbmFsTWlkZGxld2FyZSA9IG1pZGRsZXdhcmU7XHJcbiAgICBpZiAodHlwZW9mIGZpbmFsTWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgZmluYWxNaWRkbGV3YXJlID0gZmluYWxNaWRkbGV3YXJlKGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSk7XHJcbiAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2hlbiB1c2luZyBhIG1pZGRsZXdhcmUgYnVpbGRlciBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgbWlkZGxld2FyZSBtdXN0IGJlIHJldHVybmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghSVNfUFJPRFVDVElPTiAmJiBmaW5hbE1pZGRsZXdhcmUuc29tZShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIjsgfSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlYWNoIG1pZGRsZXdhcmUgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIG1pZGRsZXdhcmVFbmhhbmNlciA9IGFwcGx5TWlkZGxld2FyZS5hcHBseSh2b2lkIDAsIGZpbmFsTWlkZGxld2FyZSk7XHJcbiAgICB2YXIgZmluYWxDb21wb3NlID0gY29tcG9zZTI7XHJcbiAgICBpZiAoZGV2VG9vbHMpIHtcclxuICAgICAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OXHJcbiAgICAgICAgfSwgdHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZGVmYXVsdEVuaGFuY2VycyA9IG5ldyBFbmhhbmNlckFycmF5KG1pZGRsZXdhcmVFbmhhbmNlcik7XHJcbiAgICB2YXIgc3RvcmVFbmhhbmNlcnMgPSBkZWZhdWx0RW5oYW5jZXJzO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZW5oYW5jZXJzKSkge1xyXG4gICAgICAgIHN0b3JlRW5oYW5jZXJzID0gX19zcHJlYWRBcnJheShbbWlkZGxld2FyZUVuaGFuY2VyXSwgZW5oYW5jZXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHN0b3JlRW5oYW5jZXJzID0gZW5oYW5jZXJzKGRlZmF1bHRFbmhhbmNlcnMpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UuYXBwbHkodm9pZCAwLCBzdG9yZUVuaGFuY2Vycyk7XHJcbiAgICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBjb21wb3NlZEVuaGFuY2VyKTtcclxufVxyXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQWN0aW9uKSB7XHJcbiAgICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJlcGFyZUFjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgcHJlcGFyZWQgPSBwcmVwYXJlQWN0aW9uLmFwcGx5KHZvaWQgMCwgYXJncyk7XHJcbiAgICAgICAgICAgIGlmICghcHJlcGFyZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcHJlcGFyZWQucGF5bG9hZFxyXG4gICAgICAgICAgICB9LCBcIm1ldGFcIiBpbiBwcmVwYXJlZCAmJiB7IG1ldGE6IHByZXBhcmVkLm1ldGEgfSksIFwiZXJyb3JcIiBpbiBwcmVwYXJlZCAmJiB7IGVycm9yOiBwcmVwYXJlZC5lcnJvciB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgcGF5bG9hZDogYXJnc1swXSB9O1xyXG4gICAgfVxyXG4gICAgYWN0aW9uQ3JlYXRvci50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiXCIgKyB0eXBlOyB9O1xyXG4gICAgYWN0aW9uQ3JlYXRvci50eXBlID0gdHlwZTtcclxuICAgIGFjdGlvbkNyZWF0b3IubWF0Y2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBhY3Rpb24udHlwZSA9PT0gdHlwZTsgfTtcclxuICAgIHJldHVybiBhY3Rpb25DcmVhdG9yO1xyXG59XHJcbmZ1bmN0aW9uIGlzQWN0aW9uKGFjdGlvbikge1xyXG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYWN0aW9uKSAmJiBcInR5cGVcIiBpbiBhY3Rpb247XHJcbn1cclxuZnVuY3Rpb24gaXNGU0EoYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gaXNBY3Rpb24oYWN0aW9uKSAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIFtcInR5cGVcIiwgXCJwYXlsb2FkXCIsIFwiZXJyb3JcIiwgXCJtZXRhXCJdLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR5cGUoYWN0aW9uQ3JlYXRvcikge1xyXG4gICAgcmV0dXJuIFwiXCIgKyBhY3Rpb25DcmVhdG9yO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXHJcbmltcG9ydCBjcmVhdGVOZXh0U3RhdGUyLCB7IGlzRHJhZnQgYXMgaXNEcmFmdDIsIGlzRHJhZnRhYmxlIGFzIGlzRHJhZnRhYmxlMiB9IGZyb20gXCJpbW1lclwiO1xyXG4vLyBzcmMvbWFwQnVpbGRlcnMudHNcclxuZnVuY3Rpb24gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2soYnVpbGRlckNhbGxiYWNrKSB7XHJcbiAgICB2YXIgYWN0aW9uc01hcCA9IHt9O1xyXG4gICAgdmFyIGFjdGlvbk1hdGNoZXJzID0gW107XHJcbiAgICB2YXIgZGVmYXVsdENhc2VSZWR1Y2VyO1xyXG4gICAgdmFyIGJ1aWxkZXIgPSB7XHJcbiAgICAgICAgYWRkQ2FzZTogZnVuY3Rpb24gKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbk1hdGNoZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkTWF0Y2hlcmBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBcInN0cmluZ1wiID8gdHlwZU9yQWN0aW9uQ3JlYXRvciA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgaW4gYWN0aW9uc01hcCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkQ2FzZSBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3Rpb25zTWFwW3R5cGVdID0gcmVkdWNlcjtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRNYXRjaGVyOiBmdW5jdGlvbiAobWF0Y2hlciwgcmVkdWNlcikge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3Rpb25NYXRjaGVycy5wdXNoKHsgbWF0Y2hlcjogbWF0Y2hlciwgcmVkdWNlcjogcmVkdWNlciB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGREZWZhdWx0Q2FzZTogZnVuY3Rpb24gKHJlZHVjZXIpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZERlZmF1bHRDYXNlYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0Q2FzZVJlZHVjZXIgPSByZWR1Y2VyO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpO1xyXG4gICAgcmV0dXJuIFthY3Rpb25zTWFwLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXTtcclxufVxyXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xyXG5mdW5jdGlvbiBpc1N0YXRlRnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XHJcbn1cclxudmFyIGhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24gPSBmYWxzZTtcclxuZnVuY3Rpb24gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUsIG1hcE9yQnVpbGRlckNhbGxiYWNrLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICBpZiAoYWN0aW9uTWF0Y2hlcnMgPT09IHZvaWQgMCkgeyBhY3Rpb25NYXRjaGVycyA9IFtdOyB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBPckJ1aWxkZXJDYWxsYmFjayA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVJlZHVjZXJgIGlzIGRlcHJlY2F0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUlRLIDIuMC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVJlZHVjZXJcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgX2MgPSB0eXBlb2YgbWFwT3JCdWlsZGVyQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG1hcE9yQnVpbGRlckNhbGxiYWNrKSA6IFttYXBPckJ1aWxkZXJDYWxsYmFjaywgYWN0aW9uTWF0Y2hlcnMsIGRlZmF1bHRDYXNlUmVkdWNlcl0sIGFjdGlvbnNNYXAgPSBfY1swXSwgZmluYWxBY3Rpb25NYXRjaGVycyA9IF9jWzFdLCBmaW5hbERlZmF1bHRDYXNlUmVkdWNlciA9IF9jWzJdO1xyXG4gICAgdmFyIGdldEluaXRpYWxTdGF0ZTtcclxuICAgIGlmIChpc1N0YXRlRnVuY3Rpb24oaW5pdGlhbFN0YXRlKSkge1xyXG4gICAgICAgIGdldEluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUoKSk7IH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgZnJvemVuSW5pdGlhbFN0YXRlXzEgPSBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKTtcclxuICAgICAgICBnZXRJbml0aWFsU3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmcm96ZW5Jbml0aWFsU3RhdGVfMTsgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xyXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7IHN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCk7IH1cclxuICAgICAgICB2YXIgY2FzZVJlZHVjZXJzID0gX19zcHJlYWRBcnJheShbXHJcbiAgICAgICAgICAgIGFjdGlvbnNNYXBbYWN0aW9uLnR5cGVdXHJcbiAgICAgICAgXSwgZmluYWxBY3Rpb25NYXRjaGVycy5maWx0ZXIoZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaGVyID0gX2MubWF0Y2hlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcclxuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHZhciByZWR1Y2VyMiA9IF9jLnJlZHVjZXI7XHJcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VyMjtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoZnVuY3Rpb24gKGNyKSB7IHJldHVybiAhIWNyOyB9KS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXJzID0gW2ZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhc2VSZWR1Y2Vycy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzU3RhdGUsIGNhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChjYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRHJhZnQyKHByZXZpb3VzU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWZ0ID0gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzRHJhZnRhYmxlMihwcmV2aW91c1N0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYXNlUmVkdWNlcihwcmV2aW91c1N0YXRlLCBhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXh0U3RhdGUyKHByZXZpb3VzU3RhdGUsIGZ1bmN0aW9uIChkcmFmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgfSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmVkdWNlci5nZXRJbml0aWFsU3RhdGUgPSBnZXRJbml0aWFsU3RhdGU7XHJcbiAgICByZXR1cm4gcmVkdWNlcjtcclxufVxyXG4vLyBzcmMvY3JlYXRlU2xpY2UudHNcclxudmFyIGhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24yID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGdldFR5cGUyKHNsaWNlLCBhY3Rpb25LZXkpIHtcclxuICAgIHJldHVybiBzbGljZSArIFwiL1wiICsgYWN0aW9uS2V5O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNsaWNlKG9wdGlvbnMpIHtcclxuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lO1xyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYG5hbWVgIGlzIGEgcmVxdWlyZWQgb3B0aW9uIGZvciBjcmVhdGVTbGljZVwiKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5pdGlhbFN0YXRlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBtdXN0IHByb3ZpZGUgYW4gYGluaXRpYWxTdGF0ZWAgdmFsdWUgdGhhdCBpcyBub3QgYHVuZGVmaW5lZGAuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGBpbml0aWFsU3RhdGVgXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBpbml0aWFsU3RhdGUgPSB0eXBlb2Ygb3B0aW9ucy5pbml0aWFsU3RhdGUgPT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5pbml0aWFsU3RhdGUgOiBmcmVlemVEcmFmdGFibGUob3B0aW9ucy5pbml0aWFsU3RhdGUpO1xyXG4gICAgdmFyIHJlZHVjZXJzID0gb3B0aW9ucy5yZWR1Y2VycyB8fCB7fTtcclxuICAgIHZhciByZWR1Y2VyTmFtZXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XHJcbiAgICB2YXIgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUgPSB7fTtcclxuICAgIHZhciBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSA9IHt9O1xyXG4gICAgdmFyIGFjdGlvbkNyZWF0b3JzID0ge307XHJcbiAgICByZWR1Y2VyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocmVkdWNlck5hbWUpIHtcclxuICAgICAgICB2YXIgbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUgPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV07XHJcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlMihuYW1lLCByZWR1Y2VyTmFtZSk7XHJcbiAgICAgICAgdmFyIGNhc2VSZWR1Y2VyO1xyXG4gICAgICAgIHZhciBwcmVwYXJlQ2FsbGJhY2s7XHJcbiAgICAgICAgaWYgKFwicmVkdWNlclwiIGluIG1heWJlUmVkdWNlcldpdGhQcmVwYXJlKSB7XHJcbiAgICAgICAgICAgIGNhc2VSZWR1Y2VyID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucmVkdWNlcjtcclxuICAgICAgICAgICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNhc2VSZWR1Y2VyID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lW3JlZHVjZXJOYW1lXSA9IGNhc2VSZWR1Y2VyO1xyXG4gICAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlW3R5cGVdID0gY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgYWN0aW9uQ3JlYXRvcnNbcmVkdWNlck5hbWVdID0gcHJlcGFyZUNhbGxiYWNrID8gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVDYWxsYmFjaykgOiBjcmVhdGVBY3Rpb24odHlwZSk7XHJcbiAgICB9KTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkUmVkdWNlcigpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbjIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBvYmplY3Qgbm90YXRpb24gZm9yIGBjcmVhdGVTbGljZS5leHRyYVJlZHVjZXJzYCBpcyBkZXByZWNhdGVkLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJUSyAyLjAuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVTbGljZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2MgPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc10sIF9kID0gX2NbMF0sIGV4dHJhUmVkdWNlcnMgPSBfZCA9PT0gdm9pZCAwID8ge30gOiBfZCwgX2UgPSBfY1sxXSwgYWN0aW9uTWF0Y2hlcnMgPSBfZSA9PT0gdm9pZCAwID8gW10gOiBfZSwgX2YgPSBfY1syXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mO1xyXG4gICAgICAgIHZhciBmaW5hbENhc2VSZWR1Y2VycyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBleHRyYVJlZHVjZXJzKSwgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgZnVuY3Rpb24gKGJ1aWxkZXIpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGZpbmFsQ2FzZVJlZHVjZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZENhc2Uoa2V5LCBmaW5hbENhc2VSZWR1Y2Vyc1trZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGFjdGlvbk1hdGNoZXJzXzEgPSBhY3Rpb25NYXRjaGVyczsgX2kgPCBhY3Rpb25NYXRjaGVyc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBhY3Rpb25NYXRjaGVyc18xW19pXTtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihtLm1hdGNoZXIsIG0ucmVkdWNlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGREZWZhdWx0Q2FzZShkZWZhdWx0Q2FzZVJlZHVjZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgX3JlZHVjZXI7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgcmVkdWNlcjogZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKCFfcmVkdWNlcilcclxuICAgICAgICAgICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFjdGlvbnM6IGFjdGlvbkNyZWF0b3JzLFxyXG4gICAgICAgIGNhc2VSZWR1Y2Vyczogc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUsXHJcbiAgICAgICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghX3JlZHVjZXIpXHJcbiAgICAgICAgICAgICAgICBfcmVkdWNlciA9IGJ1aWxkUmVkdWNlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gX3JlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzXHJcbmZ1bmN0aW9uIGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaWRzOiBbXSxcclxuICAgICAgICBlbnRpdGllczoge31cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSgpIHtcclxuICAgIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShhZGRpdGlvbmFsU3RhdGUpIHtcclxuICAgICAgICBpZiAoYWRkaXRpb25hbFN0YXRlID09PSB2b2lkIDApIHsgYWRkaXRpb25hbFN0YXRlID0ge307IH1cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihnZXRJbml0aWFsRW50aXR5U3RhdGUoKSwgYWRkaXRpb25hbFN0YXRlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGdldEluaXRpYWxTdGF0ZTogZ2V0SW5pdGlhbFN0YXRlIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX3NlbGVjdG9ycy50c1xyXG5mdW5jdGlvbiBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCkge1xyXG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlKSB7XHJcbiAgICAgICAgdmFyIHNlbGVjdElkcyA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuaWRzOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RFbnRpdGllcyA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuZW50aXRpZXM7IH07XHJcbiAgICAgICAgdmFyIHNlbGVjdEFsbCA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdElkcywgc2VsZWN0RW50aXRpZXMsIGZ1bmN0aW9uIChpZHMsIGVudGl0aWVzKSB7IHJldHVybiBpZHMubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gZW50aXRpZXNbaWRdOyB9KTsgfSk7XHJcbiAgICAgICAgdmFyIHNlbGVjdElkID0gZnVuY3Rpb24gKF8sIGlkKSB7IHJldHVybiBpZDsgfTtcclxuICAgICAgICB2YXIgc2VsZWN0QnlJZCA9IGZ1bmN0aW9uIChlbnRpdGllcywgaWQpIHsgcmV0dXJuIGVudGl0aWVzW2lkXTsgfTtcclxuICAgICAgICB2YXIgc2VsZWN0VG90YWwgPSBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RJZHMsIGZ1bmN0aW9uIChpZHMpIHsgcmV0dXJuIGlkcy5sZW5ndGg7IH0pO1xyXG4gICAgICAgIGlmICghc2VsZWN0U3RhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdElkczogc2VsZWN0SWRzLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEVudGl0aWVzLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0QWxsOiBzZWxlY3RBbGwsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RUb3RhbDogc2VsZWN0VG90YWwsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RCeUlkOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMgPSBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0RW50aXRpZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNlbGVjdElkczogY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdElkcyksXHJcbiAgICAgICAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsXHJcbiAgICAgICAgICAgIHNlbGVjdEFsbDogY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdEFsbCksXHJcbiAgICAgICAgICAgIHNlbGVjdFRvdGFsOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0VG90YWwpLFxyXG4gICAgICAgICAgICBzZWxlY3RCeUlkOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBnZXRTZWxlY3RvcnM6IGdldFNlbGVjdG9ycyB9O1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9hZGFwdGVyLnRzXHJcbmltcG9ydCBjcmVhdGVOZXh0U3RhdGUzLCB7IGlzRHJhZnQgYXMgaXNEcmFmdDMgfSBmcm9tIFwiaW1tZXJcIjtcclxuZnVuY3Rpb24gY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcclxuICAgIHZhciBvcGVyYXRvciA9IGNyZWF0ZVN0YXRlT3BlcmF0b3IoZnVuY3Rpb24gKF8sIHN0YXRlKSB7IHJldHVybiBtdXRhdG9yKHN0YXRlKTsgfSk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yKHN0YXRlLCB2b2lkIDApO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUsIGFyZykge1xyXG4gICAgICAgIGZ1bmN0aW9uIGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZzIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzRlNBKGFyZzIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcnVuTXV0YXRvciA9IGZ1bmN0aW9uIChkcmFmdCkge1xyXG4gICAgICAgICAgICBpZiAoaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgbXV0YXRvcihhcmcucGF5bG9hZCwgZHJhZnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbXV0YXRvcihhcmcsIGRyYWZ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGlzRHJhZnQzKHN0YXRlKSkge1xyXG4gICAgICAgICAgICBydW5NdXRhdG9yKHN0YXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTMoc3RhdGUsIHJ1bk11dGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL3V0aWxzLnRzXHJcbmZ1bmN0aW9uIHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCkge1xyXG4gICAgdmFyIGtleSA9IHNlbGVjdElkKGVudGl0eSk7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGtleSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGVudGl0eSBwYXNzZWQgdG8gdGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgdW5kZWZpbmVkLlwiLCBcIllvdSBzaG91bGQgcHJvYmFibHkgcHJvdmlkZSB5b3VyIG93biBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uLlwiLCBcIlRoZSBlbnRpdHkgdGhhdCB3YXMgcGFzc2VkOlwiLCBlbnRpdHksIFwiVGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb246XCIsIHNlbGVjdElkLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGtleTtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVFbnRpdGllc0FycmF5KGVudGl0aWVzKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50aXRpZXMpKSB7XHJcbiAgICAgICAgZW50aXRpZXMgPSBPYmplY3QudmFsdWVzKGVudGl0aWVzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbnRpdGllcztcclxufVxyXG5mdW5jdGlvbiBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpIHtcclxuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICB2YXIgYWRkZWQgPSBbXTtcclxuICAgIHZhciB1cGRhdGVkID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0VudGl0aWVzXzEgPSBuZXdFbnRpdGllczsgX2kgPCBuZXdFbnRpdGllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBlbnRpdHkgPSBuZXdFbnRpdGllc18xW19pXTtcclxuICAgICAgICB2YXIgaWQgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xyXG4gICAgICAgIGlmIChpZCBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICB1cGRhdGVkLnB1c2goeyBpZDogaWQsIGNoYW5nZXM6IGVudGl0eSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFkZGVkLnB1c2goZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2FkZGVkLCB1cGRhdGVkXTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvdW5zb3J0ZWRfc3RhdGVfYWRhcHRlci50c1xyXG5mdW5jdGlvbiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCkge1xyXG4gICAgZnVuY3Rpb24gYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLmlkcy5wdXNoKGtleSk7XHJcbiAgICAgICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBuZXdFbnRpdGllc18yID0gbmV3RW50aXRpZXM7IF9pIDwgbmV3RW50aXRpZXNfMi5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGVudGl0eSA9IG5ld0VudGl0aWVzXzJbX2ldO1xyXG4gICAgICAgICAgICBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xyXG4gICAgICAgIGlmICghKGtleSBpbiBzdGF0ZS5lbnRpdGllcykpIHtcclxuICAgICAgICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBuZXdFbnRpdGllc18zID0gbmV3RW50aXRpZXM7IF9pIDwgbmV3RW50aXRpZXNfMy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGVudGl0eSA9IG5ld0VudGl0aWVzXzNbX2ldO1xyXG4gICAgICAgICAgICBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBzdGF0ZS5pZHMgPSBbXTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xyXG4gICAgICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVPbmVNdXRhYmx5KGtleSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gcmVtb3ZlTWFueU11dGFibHkoW2tleV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZU1hbnlNdXRhYmx5KGtleXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGRpZE11dGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1trZXldO1xyXG4gICAgICAgICAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChkaWRNdXRhdGUpIHtcclxuICAgICAgICAgICAgc3RhdGUuaWRzID0gc3RhdGUuaWRzLmZpbHRlcihmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkIGluIHN0YXRlLmVudGl0aWVzOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVBbGxNdXRhYmx5KHN0YXRlKSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwge1xyXG4gICAgICAgICAgICBpZHM6IFtdLFxyXG4gICAgICAgICAgICBlbnRpdGllczoge31cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRha2VOZXdLZXkoa2V5cywgdXBkYXRlLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBvcmlnaW5hbDIgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgIHZhciB1cGRhdGVkID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWwyLCB1cGRhdGUuY2hhbmdlcyk7XHJcbiAgICAgICAgdmFyIG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xyXG4gICAgICAgIHZhciBoYXNOZXdLZXkgPSBuZXdLZXkgIT09IHVwZGF0ZS5pZDtcclxuICAgICAgICBpZiAoaGFzTmV3S2V5KSB7XHJcbiAgICAgICAgICAgIGtleXNbdXBkYXRlLmlkXSA9IG5ld0tleTtcclxuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLmVudGl0aWVzW25ld0tleV0gPSB1cGRhdGVkO1xyXG4gICAgICAgIHJldHVybiBoYXNOZXdLZXk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG5ld0tleXMgPSB7fTtcclxuICAgICAgICB2YXIgdXBkYXRlc1BlckVudGl0eSA9IHt9O1xyXG4gICAgICAgIHVwZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7XHJcbiAgICAgICAgICAgIGlmICh1cGRhdGUuaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogdXBkYXRlLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB1cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0gPyB1cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0uY2hhbmdlcyA6IG51bGwpLCB1cGRhdGUuY2hhbmdlcylcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB1cGRhdGVzID0gT2JqZWN0LnZhbHVlcyh1cGRhdGVzUGVyRW50aXR5KTtcclxuICAgICAgICB2YXIgZGlkTXV0YXRlRW50aXRpZXMgPSB1cGRhdGVzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgaWYgKGRpZE11dGF0ZUVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHZhciBkaWRNdXRhdGVJZHMgPSB1cGRhdGVzLmZpbHRlcihmdW5jdGlvbiAodXBkYXRlKSB7IHJldHVybiB0YWtlTmV3S2V5KG5ld0tleXMsIHVwZGF0ZSwgc3RhdGUpOyB9KS5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICBpZiAoZGlkTXV0YXRlSWRzKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5pZHMgPSBPYmplY3Qua2V5cyhzdGF0ZS5lbnRpdGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBfYyA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSksIGFkZGVkID0gX2NbMF0sIHVwZGF0ZWQgPSBfY1sxXTtcclxuICAgICAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVtb3ZlQWxsOiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IocmVtb3ZlQWxsTXV0YWJseSksXHJcbiAgICAgICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxyXG4gICAgICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcclxuICAgICAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcclxuICAgICAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXHJcbiAgICAgICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxyXG4gICAgICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KSxcclxuICAgICAgICByZW1vdmVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlT25lTXV0YWJseSksXHJcbiAgICAgICAgcmVtb3ZlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVNYW55TXV0YWJseSlcclxuICAgIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL3NvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydCkge1xyXG4gICAgdmFyIF9jID0gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpLCByZW1vdmVPbmUgPSBfYy5yZW1vdmVPbmUsIHJlbW92ZU1hbnkgPSBfYy5yZW1vdmVNYW55LCByZW1vdmVBbGwgPSBfYy5yZW1vdmVBbGw7XHJcbiAgICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gYWRkTWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgdmFyIG1vZGVscyA9IG5ld0VudGl0aWVzLmZpbHRlcihmdW5jdGlvbiAobW9kZWwpIHsgcmV0dXJuICEoc2VsZWN0SWRWYWx1ZShtb2RlbCwgc2VsZWN0SWQpIGluIHN0YXRlLmVudGl0aWVzKTsgfSk7XHJcbiAgICAgICAgaWYgKG1vZGVscy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgbWVyZ2UobW9kZWxzLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNldE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgICAgIGlmIChuZXdFbnRpdGllcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgbWVyZ2UobmV3RW50aXRpZXMsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcclxuICAgICAgICBzdGF0ZS5pZHMgPSBbXTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBhcHBsaWVkVXBkYXRlcyA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgdXBkYXRlc18xID0gdXBkYXRlczsgX2kgPCB1cGRhdGVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSB1cGRhdGVzXzFbX2ldO1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcclxuICAgICAgICAgICAgaWYgKCFlbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFwcGxpZWRVcGRhdGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihlbnRpdHksIHVwZGF0ZS5jaGFuZ2VzKTtcclxuICAgICAgICAgICAgdmFyIG5ld0lkID0gc2VsZWN0SWQoZW50aXR5KTtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5pZCAhPT0gbmV3SWQpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuZW50aXRpZXNbbmV3SWRdID0gZW50aXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcHBsaWVkVXBkYXRlcykge1xyXG4gICAgICAgICAgICByZXNvcnRFbnRpdGllcyhzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICB2YXIgX2MgPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpLCBhZGRlZCA9IF9jWzBdLCB1cGRhdGVkID0gX2NbMV07XHJcbiAgICAgICAgdXBkYXRlTWFueU11dGFibHkodXBkYXRlZCwgc3RhdGUpO1xyXG4gICAgICAgIGFkZE1hbnlNdXRhYmx5KGFkZGVkLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcmVBcnJheXNFcXVhbChhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGggJiYgaSA8IGIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFbaV0gPT09IGJbaV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtZXJnZShtb2RlbHMsIHN0YXRlKSB7XHJcbiAgICAgICAgbW9kZWxzLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmVudGl0aWVzW3NlbGVjdElkKG1vZGVsKV0gPSBtb2RlbDtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXNvcnRFbnRpdGllcyhzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXNvcnRFbnRpdGllcyhzdGF0ZSkge1xyXG4gICAgICAgIHZhciBhbGxFbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoc3RhdGUuZW50aXRpZXMpO1xyXG4gICAgICAgIGFsbEVudGl0aWVzLnNvcnQoc29ydCk7XHJcbiAgICAgICAgdmFyIG5ld1NvcnRlZElkcyA9IGFsbEVudGl0aWVzLm1hcChzZWxlY3RJZCk7XHJcbiAgICAgICAgdmFyIGlkcyA9IHN0YXRlLmlkcztcclxuICAgICAgICBpZiAoIWFyZUFycmF5c0VxdWFsKGlkcywgbmV3U29ydGVkSWRzKSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZW1vdmVPbmU6IHJlbW92ZU9uZSxcclxuICAgICAgICByZW1vdmVNYW55OiByZW1vdmVNYW55LFxyXG4gICAgICAgIHJlbW92ZUFsbDogcmVtb3ZlQWxsLFxyXG4gICAgICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXHJcbiAgICAgICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcclxuICAgICAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcclxuICAgICAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXHJcbiAgICAgICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXHJcbiAgICAgICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXHJcbiAgICAgICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSlcclxuICAgIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZUVudGl0eUFkYXB0ZXIob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgIHZhciBfYyA9IF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICBzb3J0Q29tcGFyZXI6IGZhbHNlLFxyXG4gICAgICAgIHNlbGVjdElkOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHsgcmV0dXJuIGluc3RhbmNlLmlkOyB9XHJcbiAgICB9LCBvcHRpb25zKSwgc2VsZWN0SWQgPSBfYy5zZWxlY3RJZCwgc29ydENvbXBhcmVyID0gX2Muc29ydENvbXBhcmVyO1xyXG4gICAgdmFyIHN0YXRlRmFjdG9yeSA9IGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3RvcnkoKTtcclxuICAgIHZhciBzZWxlY3RvcnNGYWN0b3J5ID0gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpO1xyXG4gICAgdmFyIHN0YXRlQWRhcHRlciA9IHNvcnRDb21wYXJlciA/IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydENvbXBhcmVyKSA6IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcclxuICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7XHJcbiAgICAgICAgc2VsZWN0SWQ6IHNlbGVjdElkLFxyXG4gICAgICAgIHNvcnRDb21wYXJlcjogc29ydENvbXBhcmVyXHJcbiAgICB9LCBzdGF0ZUZhY3RvcnkpLCBzZWxlY3RvcnNGYWN0b3J5KSwgc3RhdGVBZGFwdGVyKTtcclxufVxyXG4vLyBzcmMvbmFub2lkLnRzXHJcbnZhciB1cmxBbHBoYWJldCA9IFwiTW9kdWxlU3ltYmhhc093blByLTAxMjM0NTY3ODlBQkNERUZHSE5SVmZnY3RpVXZ6X0txWVRKa0x4cFpYSWpRV1wiO1xyXG52YXIgbmFub2lkID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgIGlmIChzaXplID09PSB2b2lkIDApIHsgc2l6ZSA9IDIxOyB9XHJcbiAgICB2YXIgaWQgPSBcIlwiO1xyXG4gICAgdmFyIGkgPSBzaXplO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGlkICs9IHVybEFscGhhYmV0W01hdGgucmFuZG9tKCkgKiA2NCB8IDBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlkO1xyXG59O1xyXG4vLyBzcmMvY3JlYXRlQXN5bmNUaHVuay50c1xyXG52YXIgY29tbW9uUHJvcGVydGllcyA9IFtcclxuICAgIFwibmFtZVwiLFxyXG4gICAgXCJtZXNzYWdlXCIsXHJcbiAgICBcInN0YWNrXCIsXHJcbiAgICBcImNvZGVcIlxyXG5dO1xyXG52YXIgUmVqZWN0V2l0aFZhbHVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVqZWN0V2l0aFZhbHVlKHBheWxvYWQsIG1ldGEpIHtcclxuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xyXG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVqZWN0V2l0aFZhbHVlO1xyXG59KCkpO1xyXG52YXIgRnVsZmlsbFdpdGhNZXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRnVsZmlsbFdpdGhNZXRhKHBheWxvYWQsIG1ldGEpIHtcclxuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xyXG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRnVsZmlsbFdpdGhNZXRhO1xyXG59KCkpO1xyXG52YXIgbWluaVNlcmlhbGl6ZUVycm9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgdmFyIHNpbXBsZUVycm9yID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjb21tb25Qcm9wZXJ0aWVzXzEgPSBjb21tb25Qcm9wZXJ0aWVzOyBfaSA8IGNvbW1vblByb3BlcnRpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gY29tbW9uUHJvcGVydGllc18xW19pXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtwcm9wZXJ0eV0gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHNpbXBsZUVycm9yW3Byb3BlcnR5XSA9IHZhbHVlW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2ltcGxlRXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBtZXNzYWdlOiBTdHJpbmcodmFsdWUpIH07XHJcbn07XHJcbnZhciBjcmVhdGVBc3luY1RodW5rID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jVGh1bmsyKHR5cGVQcmVmaXgsIHBheWxvYWRDcmVhdG9yLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGZ1bGZpbGxlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvZnVsZmlsbGVkXCIsIGZ1bmN0aW9uIChwYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgbWV0YSkgeyByZXR1cm4gKHtcclxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcclxuICAgICAgICAgICAgbWV0YTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbWV0YSB8fCB7fSksIHtcclxuICAgICAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0U3RhdHVzOiBcImZ1bGZpbGxlZFwiXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7IH0pO1xyXG4gICAgICAgIHZhciBwZW5kaW5nID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9wZW5kaW5nXCIsIGZ1bmN0aW9uIChyZXF1ZXN0SWQsIGFyZywgbWV0YSkgeyByZXR1cm4gKHtcclxuICAgICAgICAgICAgcGF5bG9hZDogdm9pZCAwLFxyXG4gICAgICAgICAgICBtZXRhOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXRhIHx8IHt9KSwge1xyXG4gICAgICAgICAgICAgICAgYXJnOiBhcmcsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdGF0dXM6IFwicGVuZGluZ1wiXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7IH0pO1xyXG4gICAgICAgIHZhciByZWplY3RlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcmVqZWN0ZWRcIiwgZnVuY3Rpb24gKGVycm9yLCByZXF1ZXN0SWQsIGFyZywgcGF5bG9hZCwgbWV0YSkgeyByZXR1cm4gKHtcclxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcclxuICAgICAgICAgICAgZXJyb3I6IChvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplRXJyb3IgfHwgbWluaVNlcmlhbGl6ZUVycm9yKShlcnJvciB8fCBcIlJlamVjdGVkXCIpLFxyXG4gICAgICAgICAgICBtZXRhOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXRhIHx8IHt9KSwge1xyXG4gICAgICAgICAgICAgICAgYXJnOiBhcmcsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICAgIHJlamVjdGVkV2l0aFZhbHVlOiAhIXBheWxvYWQsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInJlamVjdGVkXCIsXHJcbiAgICAgICAgICAgICAgICBhYm9ydGVkOiAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkFib3J0RXJyb3JcIixcclxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogKGVycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5uYW1lKSA9PT0gXCJDb25kaXRpb25FcnJvclwiXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7IH0pO1xyXG4gICAgICAgIHZhciBkaXNwbGF5ZWRXYXJuaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIEFDID0gdHlwZW9mIEFib3J0Q29udHJvbGxlciAhPT0gXCJ1bmRlZmluZWRcIiA/IEFib3J0Q29udHJvbGxlciA6IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25hYm9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkFib3J0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlzcGxheWVkV2FybmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5ZWRXYXJuaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVGhpcyBwbGF0Zm9ybSBkb2VzIG5vdCBpbXBsZW1lbnQgQWJvcnRDb250cm9sbGVyLiBcXG5JZiB5b3Ugd2FudCB0byB1c2UgdGhlIEFib3J0Q29udHJvbGxlciB0byByZWFjdCB0byBgYWJvcnRgIGV2ZW50cywgcGxlYXNlIGNvbnNpZGVyIGltcG9ydGluZyBhIHBvbHlmaWxsIGxpa2UgJ2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbC9kaXN0L2Fib3J0Y29udHJvbGxlci1wb2x5ZmlsbC1vbmx5Jy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NfMTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoYXJnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RJZCA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmlkR2VuZXJhdG9yKSA/IG9wdGlvbnMuaWRHZW5lcmF0b3IoYXJnKSA6IG5hbm9pZCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFib3J0Q29udHJvbGxlciA9IG5ldyBBQygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFib3J0UmVhc29uO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0UmVhc29uID0gcmVhc29uO1xyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgZmluYWxBY3Rpb24sIGNvbmRpdGlvblJlc3VsdCwgYWJvcnRlZFByb21pc2UsIGVycl8xLCBza2lwRGlzcGF0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMCwgNCwgLCA1XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdCA9IChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29uZGl0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBhcmcsIHsgZ2V0U3RhdGU6IGdldFN0YXRlLCBleHRyYTogZXh0cmEgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNUaGVuYWJsZShjb25kaXRpb25SZXN1bHQpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY29uZGl0aW9uUmVzdWx0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdCA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCA9PT0gZmFsc2UgfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJDb25kaXRpb25FcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQWJvcnRlZCBkdWUgdG8gY29uZGl0aW9uIGNhbGxiYWNrIHJldHVybmluZyBmYWxzZS5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRlZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7IHJldHVybiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJBYm9ydEVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhYm9ydFJlYXNvbiB8fCBcIkFib3J0ZWRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChwZW5kaW5nKHJlcXVlc3RJZCwgYXJnLCAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdldFBlbmRpbmdNZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChvcHRpb25zLCB7IHJlcXVlc3RJZDogcmVxdWVzdElkLCBhcmc6IGFyZyB9LCB7IGdldFN0YXRlOiBnZXRTdGF0ZSwgZXh0cmE6IGV4dHJhIH0pKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmFjZShbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRlZFByb21pc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHBheWxvYWRDcmVhdG9yKGFyZywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IGV4dHJhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydDogYWJvcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdFdpdGhWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBtZXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlamVjdFdpdGhWYWx1ZSh2YWx1ZSwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGxXaXRoVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgbWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQucGF5bG9hZCwgcmVxdWVzdElkLCBhcmcsIHJlc3VsdC5tZXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdCwgcmVxdWVzdElkLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEFjdGlvbiA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJfMSA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBlcnJfMSBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSA/IHJlamVjdGVkKG51bGwsIHJlcXVlc3RJZCwgYXJnLCBlcnJfMS5wYXlsb2FkLCBlcnJfMS5tZXRhKSA6IHJlamVjdGVkKGVycl8xLCByZXF1ZXN0SWQsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcERpc3BhdGNoID0gb3B0aW9ucyAmJiAhb3B0aW9ucy5kaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiAmJiByZWplY3RlZC5tYXRjaChmaW5hbEFjdGlvbikgJiYgZmluYWxBY3Rpb24ubWV0YS5jb25kaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2tpcERpc3BhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChmaW5hbEFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZpbmFsQWN0aW9uXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9taXNlMiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0OiBhYm9ydCxcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgICAgICB1bndyYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UyLnRoZW4odW53cmFwUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWN0aW9uQ3JlYXRvciwge1xyXG4gICAgICAgICAgICBwZW5kaW5nOiBwZW5kaW5nLFxyXG4gICAgICAgICAgICByZWplY3RlZDogcmVqZWN0ZWQsXHJcbiAgICAgICAgICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxyXG4gICAgICAgICAgICB0eXBlUHJlZml4OiB0eXBlUHJlZml4XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVBc3luY1RodW5rMi53aXRoVHlwZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVBc3luY1RodW5rMjsgfTtcclxuICAgIHJldHVybiBjcmVhdGVBc3luY1RodW5rMjtcclxufSkoKTtcclxuZnVuY3Rpb24gdW53cmFwUmVzdWx0KGFjdGlvbikge1xyXG4gICAgaWYgKGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3cgYWN0aW9uLnBheWxvYWQ7XHJcbiAgICB9XHJcbiAgICBpZiAoYWN0aW9uLmVycm9yKSB7XHJcbiAgICAgICAgdGhyb3cgYWN0aW9uLmVycm9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGhlbmFibGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG4vLyBzcmMvdHNIZWxwZXJzLnRzXHJcbnZhciBoYXNNYXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XHJcbn07XHJcbi8vIHNyYy9tYXRjaGVycy50c1xyXG52YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIChtYXRjaGVyLCBhY3Rpb24pIHtcclxuICAgIGlmIChoYXNNYXRjaEZ1bmN0aW9uKG1hdGNoZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIubWF0Y2goYWN0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGlzQW55T2YoKSB7XHJcbiAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgbWF0Y2hlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoZnVuY3Rpb24gKG1hdGNoZXIpIHsgcmV0dXJuIG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKTsgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzQWxsT2YoKSB7XHJcbiAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgbWF0Y2hlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KGZ1bmN0aW9uIChtYXRjaGVyKSB7IHJldHVybiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbik7IH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XHJcbiAgICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcclxuICAgIHZhciBoYXNWYWxpZFJlcXVlc3RTdGF0dXMgPSB2YWxpZFN0YXR1cy5pbmRleE9mKGFjdGlvbi5tZXRhLnJlcXVlc3RTdGF0dXMpID4gLTE7XHJcbiAgICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcclxuICAgIHJldHVybiB0eXBlb2YgYVswXSA9PT0gXCJmdW5jdGlvblwiICYmIFwicGVuZGluZ1wiIGluIGFbMF0gJiYgXCJmdWxmaWxsZWRcIiBpbiBhWzBdICYmIFwicmVqZWN0ZWRcIiBpbiBhWzBdO1xyXG59XHJcbmZ1bmN0aW9uIGlzUGVuZGluZygpIHtcclxuICAgIHZhciBhc3luY1RodW5rcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhc3luY1RodW5rc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoZnVuY3Rpb24gKGFzeW5jVGh1bmspIHsgcmV0dXJuIGFzeW5jVGh1bmsucGVuZGluZzsgfSk7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1JlamVjdGVkKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWplY3RlZCgpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKGZ1bmN0aW9uIChhc3luY1RodW5rKSB7IHJldHVybiBhc3luY1RodW5rLnJlamVjdGVkOyB9KTtcclxuICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZi5hcHBseSh2b2lkIDAsIG1hdGNoZXJzKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBoYXNGbGFnID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FsbE9mKGlzUmVqZWN0ZWQuYXBwbHkodm9pZCAwLCBhc3luY1RodW5rcyksIGhhc0ZsYWcpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FsbE9mKGlzUmVqZWN0ZWQuYXBwbHkodm9pZCAwLCBhc3luY1RodW5rcyksIGhhc0ZsYWcpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJmdWxmaWxsZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcChmdW5jdGlvbiAoYXN5bmNUaHVuaykgeyByZXR1cm4gYXN5bmNUaHVuay5mdWxmaWxsZWQ7IH0pO1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mLmFwcGx5KHZvaWQgMCwgbWF0Y2hlcnMpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNBc3luY1RodW5rQWN0aW9uKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTsgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQXN5bmNUaHVua0FjdGlvbigpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBhc3luY1RodW5rc18xID0gYXN5bmNUaHVua3M7IF9pIDwgYXN5bmNUaHVua3NfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGFzeW5jVGh1bmsgPSBhc3luY1RodW5rc18xW19pXTtcclxuICAgICAgICAgICAgbWF0Y2hlcnMucHVzaChhc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3V0aWxzLnRzXHJcbnZhciBhc3NlcnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jLCBleHBlY3RlZCkge1xyXG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGV4cGVjdGVkICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XHJcbiAgICB9XHJcbn07XHJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG52YXIgY2F0Y2hSZWplY3Rpb24gPSBmdW5jdGlvbiAocHJvbWlzZTIsIG9uRXJyb3IpIHtcclxuICAgIGlmIChvbkVycm9yID09PSB2b2lkIDApIHsgb25FcnJvciA9IG5vb3A7IH1cclxuICAgIHByb21pc2UyLmNhdGNoKG9uRXJyb3IpO1xyXG4gICAgcmV0dXJuIHByb21pc2UyO1xyXG59O1xyXG52YXIgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IGZ1bmN0aW9uIChhYm9ydFNpZ25hbCwgY2FsbGJhY2spIHtcclxuICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywgeyBvbmNlOiB0cnVlIH0pO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjayk7IH07XHJcbn07XHJcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gZnVuY3Rpb24gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSB7XHJcbiAgICB2YXIgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcclxuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJlYXNvbixcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbik7XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xyXG52YXIgdGFzayA9IFwidGFza1wiO1xyXG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XHJcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xyXG52YXIgY2FuY2VsbGVkID0gXCJjYW5jZWxsZWRcIjtcclxudmFyIHRhc2tDYW5jZWxsZWQgPSBcInRhc2stXCIgKyBjYW5jZWxsZWQ7XHJcbnZhciB0YXNrQ29tcGxldGVkID0gXCJ0YXNrLVwiICsgY29tcGxldGVkO1xyXG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY2FuY2VsbGVkO1xyXG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY29tcGxldGVkO1xyXG52YXIgVGFza0Fib3J0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUYXNrQWJvcnRFcnJvcihjb2RlKSB7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGFzayArIFwiIFwiICsgY2FuY2VsbGVkICsgXCIgKHJlYXNvbjogXCIgKyBjb2RlICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVGFza0Fib3J0RXJyb3I7XHJcbn0oKSk7XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xyXG52YXIgdmFsaWRhdGVBY3RpdmUgPSBmdW5jdGlvbiAoc2lnbmFsKSB7XHJcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbik7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZTIpIHtcclxuICAgIHZhciBjbGVhbnVwID0gbm9vcDtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIG5vdGlmeVJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbikpOyB9O1xyXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgICAgICBub3RpZnlSZWplY3Rpb24oKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XHJcbiAgICAgICAgcHJvbWlzZTIuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhbnVwKCk7IH0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNsZWFudXAgPSBub29wO1xyXG4gICAgfSk7XHJcbn1cclxudmFyIHJ1blRhc2sgPSBmdW5jdGlvbiAodGFzazIsIGNsZWFuVXApIHsgcmV0dXJuIF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdmFsdWUsIGVycm9yXzE7XHJcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsIDMsIDQsIDVdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZSgpXTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFzazIoKV07XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIm9rXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvcl8xIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JfMVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjbGVhblVwID09IG51bGwgPyB2b2lkIDAgOiBjbGVhblVwKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7IH07XHJcbnZhciBjcmVhdGVQYXVzZSA9IGZ1bmN0aW9uIChzaWduYWwpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvbWlzZTIpIHtcclxuICAgICAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlMikudGhlbihmdW5jdGlvbiAob3V0cHV0KSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxufTtcclxudmFyIGNyZWF0ZURlbGF5ID0gZnVuY3Rpb24gKHNpZ25hbCkge1xyXG4gICAgdmFyIHBhdXNlID0gY3JlYXRlUGF1c2Uoc2lnbmFsKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGltZW91dE1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdXNlKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXRNcyk7IH0pKTtcclxuICAgIH07XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcclxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XHJcbnZhciBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fTtcclxudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XHJcbnZhciBjcmVhdGVGb3JrID0gZnVuY3Rpb24gKHBhcmVudEFib3J0U2lnbmFsKSB7XHJcbiAgICB2YXIgbGlua0NvbnRyb2xsZXJzID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHsgcmV0dXJuIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIocGFyZW50QWJvcnRTaWduYWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgcGFyZW50QWJvcnRTaWduYWwucmVhc29uKTsgfSk7IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhc2tFeGVjdXRvcikge1xyXG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKHRhc2tFeGVjdXRvciwgXCJ0YXNrRXhlY3V0b3JcIik7XHJcbiAgICAgICAgdmFyIGNoaWxkQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJ1blRhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHBhcmVudEFib3J0U2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFza0V4ZWN1dG9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdDJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NvbXBsZXRlZCk7IH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlc3VsdDogY3JlYXRlUGF1c2UocGFyZW50QWJvcnRTaWduYWwpKHJlc3VsdCksXHJcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufTtcclxudmFyIGNyZWF0ZVRha2VQYXR0ZXJuID0gZnVuY3Rpb24gKHN0YXJ0TGlzdGVuaW5nLCBzaWduYWwpIHtcclxuICAgIHZhciB0YWtlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGltZW91dCkgeyByZXR1cm4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdW5zdWJzY3JpYmUsIHR1cGxlUHJvbWlzZSwgcHJvbWlzZXMsIG91dHB1dDtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdHVwbGVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcExpc3RlbmluZyA9IHN0YXJ0TGlzdGVuaW5nKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZTogcHJlZGljYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0OiBmdW5jdGlvbiAoYWN0aW9uLCBsaXN0ZW5lckFwaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXBpLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJBcGkuZ2V0U3RhdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJBcGkuZ2V0T3JpZ2luYWxTdGF0ZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BMaXN0ZW5pbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0dXBsZVByb21pc2VcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0LCBudWxsKTsgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxLCAsIDMsIDRdKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByYWNlV2l0aFNpZ25hbChzaWduYWwsIFByb21pc2UucmFjZShwcm9taXNlcykpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgb3V0cHV0XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGltZW91dCkgeyByZXR1cm4gY2F0Y2hSZWplY3Rpb24odGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpKTsgfTtcclxufTtcclxudmFyIGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGUsIGFjdGlvbkNyZWF0b3IgPSBvcHRpb25zLmFjdGlvbkNyZWF0b3IsIG1hdGNoZXIgPSBvcHRpb25zLm1hdGNoZXIsIHByZWRpY2F0ZSA9IG9wdGlvbnMucHJlZGljYXRlLCBlZmZlY3QgPSBvcHRpb25zLmVmZmVjdDtcclxuICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgcHJlZGljYXRlID0gY3JlYXRlQWN0aW9uKHR5cGUpLm1hdGNoO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYWN0aW9uQ3JlYXRvcikge1xyXG4gICAgICAgIHR5cGUgPSBhY3Rpb25DcmVhdG9yLnR5cGU7XHJcbiAgICAgICAgcHJlZGljYXRlID0gYWN0aW9uQ3JlYXRvci5tYXRjaDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1hdGNoZXIpIHtcclxuICAgICAgICBwcmVkaWNhdGUgPSBtYXRjaGVyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJlZGljYXRlKSB7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDcmVhdGluZyBvciByZW1vdmluZyBhIGxpc3RlbmVyIHJlcXVpcmVzIG9uZSBvZiB0aGUga25vd24gZmllbGRzIGZvciBtYXRjaGluZyBhbiBhY3Rpb25cIik7XHJcbiAgICB9XHJcbiAgICBhc3NlcnRGdW5jdGlvbihlZmZlY3QsIFwib3B0aW9ucy5saXN0ZW5lclwiKTtcclxuICAgIHJldHVybiB7IHByZWRpY2F0ZTogcHJlZGljYXRlLCB0eXBlOiB0eXBlLCBlZmZlY3Q6IGVmZmVjdCB9O1xyXG59O1xyXG52YXIgY3JlYXRlTGlzdGVuZXJFbnRyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgX2MgPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpLCB0eXBlID0gX2MudHlwZSwgcHJlZGljYXRlID0gX2MucHJlZGljYXRlLCBlZmZlY3QgPSBfYy5lZmZlY3Q7XHJcbiAgICB2YXIgaWQgPSBuYW5vaWQoKTtcclxuICAgIHZhciBlbnRyeSA9IHtcclxuICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgZWZmZWN0OiBlZmZlY3QsXHJcbiAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcclxuICAgICAgICBwZW5kaW5nOiBuZXcgU2V0KCksXHJcbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdWJzY3JpYmUgbm90IGluaXRpYWxpemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gZW50cnk7XHJcbn07XHJcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xyXG4gICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IGZ1bmN0aW9uIChsaXN0ZW5lck1hcCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsaXN0ZW5lck1hcC5mb3JFYWNoKGNhbmNlbEFjdGl2ZUxpc3RlbmVycyk7XHJcbiAgICAgICAgbGlzdGVuZXJNYXAuY2xlYXIoKTtcclxuICAgIH07XHJcbn07XHJcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JUb05vdGlmeSwgZXJyb3JJbmZvKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvckhhbmRsZXJFcnJvcjtcclxuICAgICAgICB9LCAwKTtcclxuICAgIH1cclxufTtcclxudmFyIGFkZExpc3RlbmVyID0gY3JlYXRlQWN0aW9uKGFsbSArIFwiL2FkZFwiKTtcclxudmFyIGNsZWFyQWxsTGlzdGVuZXJzID0gY3JlYXRlQWN0aW9uKGFsbSArIFwiL3JlbW92ZUFsbFwiKTtcclxudmFyIHJlbW92ZUxpc3RlbmVyID0gY3JlYXRlQWN0aW9uKGFsbSArIFwiL3JlbW92ZVwiKTtcclxudmFyIGRlZmF1bHRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIF9fc3ByZWFkQXJyYXkoW2FsbSArIFwiL2Vycm9yXCJdLCBhcmdzKSk7XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZShtaWRkbGV3YXJlT3B0aW9ucykge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIGlmIChtaWRkbGV3YXJlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IG1pZGRsZXdhcmVPcHRpb25zID0ge307IH1cclxuICAgIHZhciBsaXN0ZW5lck1hcCA9IG5ldyBNYXAoKTtcclxuICAgIHZhciBleHRyYSA9IG1pZGRsZXdhcmVPcHRpb25zLmV4dHJhLCBfYyA9IG1pZGRsZXdhcmVPcHRpb25zLm9uRXJyb3IsIG9uRXJyb3IgPSBfYyA9PT0gdm9pZCAwID8gZGVmYXVsdEVycm9ySGFuZGxlciA6IF9jO1xyXG4gICAgYXNzZXJ0RnVuY3Rpb24ob25FcnJvciwgXCJvbkVycm9yXCIpO1xyXG4gICAgdmFyIGluc2VydEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgZW50cnkudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpOyB9O1xyXG4gICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FuY2VsT3B0aW9ucykge1xyXG4gICAgICAgICAgICBlbnRyeS51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICBpZiAoY2FuY2VsT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY2FuY2VsT3B0aW9ucy5jYW5jZWxBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHZhciBmaW5kTGlzdGVuZXJFbnRyeSA9IGZ1bmN0aW9uIChjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpOyBfaSA8IF9jLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBfY1tfaV07XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGVudHJ5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2b2lkIDA7XHJcbiAgICB9O1xyXG4gICAgdmFyIHN0YXJ0TGlzdGVuaW5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShmdW5jdGlvbiAoZXhpc3RpbmdFbnRyeSkgeyByZXR1cm4gZXhpc3RpbmdFbnRyeS5lZmZlY3QgPT09IG9wdGlvbnMuZWZmZWN0OyB9KTtcclxuICAgICAgICBpZiAoIWVudHJ5KSB7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gY3JlYXRlTGlzdGVuZXJFbnRyeShvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc2VydEVudHJ5KGVudHJ5KTtcclxuICAgIH07XHJcbiAgICB2YXIgc3RvcExpc3RlbmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9jID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKSwgdHlwZSA9IF9jLnR5cGUsIGVmZmVjdCA9IF9jLmVmZmVjdCwgcHJlZGljYXRlID0gX2MucHJlZGljYXRlO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IGZpbmRMaXN0ZW5lckVudHJ5KGZ1bmN0aW9uIChlbnRyeTIpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoUHJlZGljYXRlT3JUeXBlID0gdHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgPyBlbnRyeTIudHlwZSA9PT0gdHlwZSA6IGVudHJ5Mi5wcmVkaWNhdGUgPT09IHByZWRpY2F0ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5Mi5lZmZlY3QgPT09IGVmZmVjdDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhIWVudHJ5O1xyXG4gICAgfTtcclxuICAgIHZhciBub3RpZnlMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpIHsgcmV0dXJuIF9fYXN5bmMoX3RoaXMsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgdGFrZSwgbGlzdGVuZXJFcnJvcl8xO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsVGFza0NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFrZSA9IGNyZWF0ZVRha2VQYXR0ZXJuKHN0YXJ0TGlzdGVuaW5nLCBpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMSwgMywgNCwgNV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZShlbnRyeS5lZmZlY3QoYWN0aW9uLCBhc3NpZ24oe30sIGFwaSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3JpZ2luYWxTdGF0ZTogZ2V0T3JpZ2luYWxTdGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogZnVuY3Rpb24gKHByZWRpY2F0ZSwgdGltZW91dCkgeyByZXR1cm4gdGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpLnRoZW4oQm9vbGVhbik7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWtlOiB0YWtlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yazogY3JlYXRlRm9yayhpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZTogZW50cnkudW5zdWJzY3JpYmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIsIF8sIHNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlciAhPT0gaW50ZXJuYWxUYXNrQ29udHJvbGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQuZGVsZXRlKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckVycm9yXzEgPSBfYy5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobGlzdGVuZXJFcnJvcl8xIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIGxpc3RlbmVyRXJyb3JfMSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDb21wbGV0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbiAgICB2YXIgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XHJcbiAgICB2YXIgbWlkZGxld2FyZSA9IGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFpc0FjdGlvbihhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGRMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFydExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjbGVhckFsbExpc3RlbmVycy5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbW92ZUxpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0b3BMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luYWxTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciBnZXRPcmlnaW5hbFN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxTdGF0ZSA9PT0gSU5URVJOQUxfTklMX1RPS0VOKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYWxtICsgXCI6IGdldE9yaWdpbmFsU3RhdGUgY2FuIG9ubHkgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyTWFwLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJFbnRyaWVzID0gQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGxpc3RlbmVyRW50cmllc18xID0gbGlzdGVuZXJFbnRyaWVzOyBfaSA8IGxpc3RlbmVyRW50cmllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGxpc3RlbmVyRW50cmllc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcnVuTGlzdGVuZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChwcmVkaWNhdGVFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2VkQnk6IFwicHJlZGljYXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVyKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9OyB9OyB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtaWRkbGV3YXJlOiBtaWRkbGV3YXJlLFxyXG4gICAgICAgIHN0YXJ0TGlzdGVuaW5nOiBzdGFydExpc3RlbmluZyxcclxuICAgICAgICBzdG9wTGlzdGVuaW5nOiBzdG9wTGlzdGVuaW5nLFxyXG4gICAgICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcclxudmFyIFNIT1VMRF9BVVRPQkFUQ0ggPSBcIlJUS19hdXRvQmF0Y2hcIjtcclxudmFyIHByZXBhcmVBdXRvQmF0Y2hlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7XHJcbiAgICB2YXIgX2M7XHJcbiAgICByZXR1cm4gKHtcclxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgIG1ldGE6IChfYyA9IHt9LCBfY1tTSE9VTERfQVVUT0JBVENIXSA9IHRydWUsIF9jKVxyXG4gICAgfSk7XHJcbn07IH07XHJcbnZhciBwcm9taXNlO1xyXG52YXIgcXVldWVNaWNyb3Rhc2tTaGltID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSBcImZ1bmN0aW9uXCIgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogZ2xvYmFsVGhpcykgOiBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIChwcm9taXNlIHx8IChwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpKS50aGVuKGNiKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgIHRocm93IGVycjtcclxufSwgMCk7IH0pOyB9O1xyXG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSBmdW5jdGlvbiAodGltZW91dCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub3RpZnkpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KG5vdGlmeSwgdGltZW91dCk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgckFGID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKTtcclxudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgdHlwZTogXCJyYWZcIiB9OyB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0b3JlID0gbmV4dC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xyXG4gICAgICAgIHZhciBub3RpZnlpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHZhciBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSBcInRpY2tcIiA/IHF1ZXVlTWljcm90YXNrU2hpbSA6IG9wdGlvbnMudHlwZSA9PT0gXCJyYWZcIiA/IHJBRiA6IG9wdGlvbnMudHlwZSA9PT0gXCJjYWxsYmFja1wiID8gb3B0aW9ucy5xdWV1ZU5vdGlmaWNhdGlvbiA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKG9wdGlvbnMudGltZW91dCk7XHJcbiAgICAgICAgdmFyIG5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsKCk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUsIHtcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobGlzdGVuZXIyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZExpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbm90aWZ5aW5nICYmIGxpc3RlbmVyMigpOyB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKHdyYXBwZWRMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5aW5nID0gISgoX2EgPSBhY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGlvbi5tZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2FbU0hPVUxEX0FVVE9CQVRDSF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub3RpZmljYXRpb25RdWV1ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUNhbGxiYWNrKG5vdGlmeUxpc3RlbmVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9OyB9O1xyXG59O1xyXG4vLyBzcmMvaW5kZXgudHNcclxuZW5hYmxlRVM1KCk7XHJcbmV4cG9ydCB7IEVuaGFuY2VyQXJyYXksIE1pZGRsZXdhcmVBcnJheSwgU0hPVUxEX0FVVE9CQVRDSCwgVGFza0Fib3J0RXJyb3IsIGFkZExpc3RlbmVyLCBhdXRvQmF0Y2hFbmhhbmNlciwgY2xlYXJBbGxMaXN0ZW5lcnMsIGNvbmZpZ3VyZVN0b3JlLCBjcmVhdGVBY3Rpb24sIGNyZWF0ZUFzeW5jVGh1bmssIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLCBjcmVhdGVFbnRpdHlBZGFwdGVyLCBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSwgZGVmYXVsdDIgYXMgY3JlYXRlTmV4dFN0YXRlLCBjcmVhdGVSZWR1Y2VyLCBjcmVhdGVTZWxlY3RvcjIgYXMgY3JlYXRlU2VsZWN0b3IsIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSwgY3JlYXRlU2xpY2UsIGN1cnJlbnQyIGFzIGN1cnJlbnQsIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSwgZnJlZXplLCBnZXREZWZhdWx0TWlkZGxld2FyZSwgZ2V0VHlwZSwgaXNBY3Rpb24sIGlzQWxsT2YsIGlzQW55T2YsIGlzQXN5bmNUaHVua0FjdGlvbiwgaXNEcmFmdDQgYXMgaXNEcmFmdCwgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sIGlzRnVsZmlsbGVkLCBpc0ltbXV0YWJsZURlZmF1bHQsIGlzUGVuZGluZywgaXNQbGFpbiwgaXNQbGFpbk9iamVjdCwgaXNSZWplY3RlZCwgaXNSZWplY3RlZFdpdGhWYWx1ZSwgbWluaVNlcmlhbGl6ZUVycm9yLCBuYW5vaWQsIG9yaWdpbmFsLCBwcmVwYXJlQXV0b0JhdGNoZWQsIHJlbW92ZUxpc3RlbmVyLCB1bndyYXBSZXN1bHQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgtdG9vbGtpdC5lc20uanMubWFwIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fZ2VuZXJhdG9yIiwidGhpc0FyZyIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJuZXh0IiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibiIsInYiLCJzdGVwIiwib3AiLCJkb25lIiwidmFsdWUiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiZSIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJpIiwiaWwiLCJqIiwiX19kZWZQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZlByb3BzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fZ2V0T3duUHJvcERlc2NzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJfX3Byb3BJc0VudW0iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fc3ByZWFkVmFsdWVzIiwiYSIsInByb3AiLCJfaSIsIl9jIiwiX19zcHJlYWRQcm9wcyIsIl9fYXN5bmMiLCJfX3RoaXMiLCJfX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJ0aHJvdyIsIngiLCJ0aGVuIiwiYXBwbHkiLCJlbmFibGVFUzUiLCJkZWZhdWx0IiwiZGVmYXVsdDIiLCJjdXJyZW50IiwiY3VycmVudDIiLCJmcmVlemUiLCJvcmlnaW5hbCIsImlzRHJhZnQiLCJpc0RyYWZ0NCIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU2VsZWN0b3IyIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJhcmdzIiwiYXJndW1lbnRzIiwic2VsZWN0b3IiLCJ3cmFwcGVkU2VsZWN0b3IiLCJyZXN0IiwiY3JlYXRlU3RvcmUiLCJjb21wb3NlIiwiY29tcG9zZTIiLCJhcHBseU1pZGRsZXdhcmUiLCJjb21iaW5lUmVkdWNlcnMiLCJjb21wb3NlV2l0aERldlRvb2xzIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIiwiZGV2VG9vbHNFbmhhbmNlciIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJub29wMiIsImlzUGxhaW5PYmplY3QiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiYmFzZVByb3RvIiwidGh1bmtNaWRkbGV3YXJlIiwiY3JlYXRlTmV4dFN0YXRlIiwiaXNEcmFmdGFibGUiLCJnZXRUaW1lTWVhc3VyZVV0aWxzIiwibWF4RGVsYXkiLCJmbk5hbWUiLCJlbGFwc2VkIiwibWVhc3VyZVRpbWUiLCJmbiIsInN0YXJ0ZWQiLCJEYXRlIiwibm93IiwiZmluaXNoZWQiLCJ3YXJuSWZFeGNlZWRlZCIsImNvbnNvbGUiLCJ3YXJuIiwiTWlkZGxld2FyZUFycmF5IiwiX3N1cGVyIiwiX3RoaXMiLCJzcGVjaWVzIiwiZ2V0IiwiY29uY2F0IiwiYXJyIiwicHJlcGVuZCIsImlzQXJyYXkiLCJiaW5kIiwiRW5oYW5jZXJBcnJheSIsImZyZWV6ZURyYWZ0YWJsZSIsInZhbCIsImlzUHJvZHVjdGlvbiIsInByb2Nlc3MiLCJwcmVmaXgiLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJzdHJpbmdpZnkiLCJzZXJpYWxpemVyIiwiaW5kZW50IiwiZGVjeWNsZXIiLCJKU09OIiwiZ2V0U2VyaWFsaXplIiwic3RhY2siLCJrZXlzIiwic2xpY2UiLCJpbmRleE9mIiwiam9pbiIsInRoaXNQb3MiLCJzcGxpY2UiLCJJbmZpbml0eSIsImlzSW1tdXRhYmxlRGVmYXVsdCIsImlzRnJvemVuIiwidHJhY2tGb3JNdXRhdGlvbnMiLCJpc0ltbXV0YWJsZSIsImlnbm9yZVBhdGhzIiwidHJhY2tlZFByb3BlcnRpZXMiLCJ0cmFja1Byb3BlcnRpZXMiLCJkZXRlY3RNdXRhdGlvbnMiLCJwYXRoIiwidHJhY2tlZCIsImNoaWxkcmVuIiwiY2hpbGRQYXRoIiwiaWdub3JlZFBhdGhzIiwidHJhY2tlZFByb3BlcnR5Iiwic2FtZVBhcmVudFJlZiIsInByZXZPYmoiLCJzYW1lUmVmIiwiTnVtYmVyIiwiaXNOYU4iLCJ3YXNNdXRhdGVkIiwia2V5c1RvRGV0ZWN0IiwiaGFzSWdub3JlZFBhdGhzIiwiX2xvb3BfMSIsIm5lc3RlZFBhdGgiLCJoYXNNYXRjaGVzIiwic29tZSIsImlnbm9yZWQiLCJSZWdFeHAiLCJ0ZXN0IiwicmVzdWx0Iiwic3RhdGVfMSIsImNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSIsIm9wdGlvbnMiLCJhY3Rpb24iLCJfZCIsIndhcm5BZnRlciIsImlnbm9yZSIsInRyYWNrIiwiZ2V0U3RhdGUiLCJzdGF0ZSIsInRyYWNrZXIiLCJtZWFzdXJlVXRpbHMiLCJkaXNwYXRjaGVkQWN0aW9uIiwiaXNQbGFpbiIsInR5cGUiLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJjYWNoZSIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImhhcyIsImVudHJpZXMiLCJfbG9vcF8yIiwibmVzdGVkVmFsdWUiLCJlbnRyaWVzXzEiLCJzdGF0ZV8yIiwiaXNOZXN0ZWRGcm96ZW4iLCJhZGQiLCJ2YWx1ZXMiLCJjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJpZ25vcmVkQWN0aW9ucyIsIl9lIiwiaWdub3JlZEFjdGlvblBhdGhzIiwiX2YiLCJfZyIsIl9oIiwiaWdub3JlU3RhdGUiLCJfaiIsImlnbm9yZUFjdGlvbnMiLCJfayIsImRpc2FibGVDYWNoZSIsIldlYWtTZXQiLCJzdG9yZUFQSSIsImZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJlcnJvciIsImZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSIsImlzQm9vbGVhbiIsImN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJjdXJyaWVkR2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJnZXREZWZhdWx0TWlkZGxld2FyZSIsInRodW5rIiwiaW1tdXRhYmxlQ2hlY2siLCJzZXJpYWxpemFibGVDaGVjayIsIm1pZGRsZXdhcmVBcnJheSIsIndpdGhFeHRyYUFyZ3VtZW50IiwiZXh0cmFBcmd1bWVudCIsImltbXV0YWJsZU9wdGlvbnMiLCJ1bnNoaWZ0Iiwic2VyaWFsaXphYmxlT3B0aW9ucyIsIklTX1BST0RVQ1RJT04iLCJjb25maWd1cmVTdG9yZSIsInJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiZGV2VG9vbHMiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VycyIsInJvb3RSZWR1Y2VyIiwiZmluYWxNaWRkbGV3YXJlIiwiaXRlbSIsIm1pZGRsZXdhcmVFbmhhbmNlciIsImZpbmFsQ29tcG9zZSIsInRyYWNlIiwiZGVmYXVsdEVuaGFuY2VycyIsInN0b3JlRW5oYW5jZXJzIiwiY29tcG9zZWRFbmhhbmNlciIsImNyZWF0ZUFjdGlvbiIsInByZXBhcmVBY3Rpb24iLCJhY3Rpb25DcmVhdG9yIiwicHJlcGFyZWQiLCJwYXlsb2FkIiwibWV0YSIsInRvU3RyaW5nIiwibWF0Y2giLCJpc0FjdGlvbiIsImlzRlNBIiwiZXZlcnkiLCJpc1ZhbGlkS2V5IiwiZ2V0VHlwZSIsImNyZWF0ZU5leHRTdGF0ZTIiLCJpc0RyYWZ0MiIsImlzRHJhZnRhYmxlMiIsImV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrIiwiYnVpbGRlckNhbGxiYWNrIiwiYWN0aW9uc01hcCIsImFjdGlvbk1hdGNoZXJzIiwiZGVmYXVsdENhc2VSZWR1Y2VyIiwiYnVpbGRlciIsImFkZENhc2UiLCJ0eXBlT3JBY3Rpb25DcmVhdG9yIiwiYWRkTWF0Y2hlciIsIm1hdGNoZXIiLCJhZGREZWZhdWx0Q2FzZSIsImlzU3RhdGVGdW5jdGlvbiIsImhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24iLCJjcmVhdGVSZWR1Y2VyIiwiaW5pdGlhbFN0YXRlIiwibWFwT3JCdWlsZGVyQ2FsbGJhY2siLCJmaW5hbEFjdGlvbk1hdGNoZXJzIiwiZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXIiLCJnZXRJbml0aWFsU3RhdGUiLCJmcm96ZW5Jbml0aWFsU3RhdGVfMSIsImNhc2VSZWR1Y2VycyIsImZpbHRlciIsIm1hcCIsInJlZHVjZXIyIiwiY3IiLCJyZWR1Y2UiLCJwcmV2aW91c1N0YXRlIiwiY2FzZVJlZHVjZXIiLCJkcmFmdCIsImhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24yIiwiZ2V0VHlwZTIiLCJhY3Rpb25LZXkiLCJjcmVhdGVTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsInJlZHVjZXJOYW1lcyIsInNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lIiwic2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUiLCJhY3Rpb25DcmVhdG9ycyIsImZvckVhY2giLCJyZWR1Y2VyTmFtZSIsIm1heWJlUmVkdWNlcldpdGhQcmVwYXJlIiwicHJlcGFyZUNhbGxiYWNrIiwicHJlcGFyZSIsImJ1aWxkUmVkdWNlciIsImV4dHJhUmVkdWNlcnMiLCJmaW5hbENhc2VSZWR1Y2VycyIsImFjdGlvbk1hdGNoZXJzXzEiLCJtIiwiX3JlZHVjZXIiLCJhY3Rpb25zIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5IiwiYWRkaXRpb25hbFN0YXRlIiwiYXNzaWduIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0SWRzIiwic2VsZWN0RW50aXRpZXMiLCJzZWxlY3RBbGwiLCJpZCIsInNlbGVjdElkIiwic2VsZWN0QnlJZCIsInNlbGVjdFRvdGFsIiwic2VsZWN0R2xvYmFsaXplZEVudGl0aWVzIiwiY3JlYXRlTmV4dFN0YXRlMyIsImlzRHJhZnQzIiwiY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yIiwibXV0YXRvciIsIm9wZXJhdG9yIiwiY3JlYXRlU3RhdGVPcGVyYXRvciIsIm9wZXJhdGlvbiIsImFyZyIsImlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50IiwiYXJnMiIsInJ1bk11dGF0b3IiLCJzZWxlY3RJZFZhbHVlIiwiZW50aXR5IiwiZW5zdXJlRW50aXRpZXNBcnJheSIsInNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMiLCJuZXdFbnRpdGllcyIsImFkZGVkIiwidXBkYXRlZCIsIm5ld0VudGl0aWVzXzEiLCJjaGFuZ2VzIiwiY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJhZGRPbmVNdXRhYmx5IiwiYWRkTWFueU11dGFibHkiLCJuZXdFbnRpdGllc18yIiwic2V0T25lTXV0YWJseSIsInNldE1hbnlNdXRhYmx5IiwibmV3RW50aXRpZXNfMyIsInNldEFsbE11dGFibHkiLCJyZW1vdmVPbmVNdXRhYmx5IiwicmVtb3ZlTWFueU11dGFibHkiLCJkaWRNdXRhdGUiLCJyZW1vdmVBbGxNdXRhYmx5IiwidGFrZU5ld0tleSIsInVwZGF0ZSIsIm9yaWdpbmFsMiIsIm5ld0tleSIsImhhc05ld0tleSIsInVwZGF0ZU9uZU11dGFibHkiLCJ1cGRhdGVNYW55TXV0YWJseSIsInVwZGF0ZXMiLCJuZXdLZXlzIiwidXBkYXRlc1BlckVudGl0eSIsImRpZE11dGF0ZUVudGl0aWVzIiwiZGlkTXV0YXRlSWRzIiwidXBzZXJ0T25lTXV0YWJseSIsInVwc2VydE1hbnlNdXRhYmx5IiwicmVtb3ZlQWxsIiwiYWRkT25lIiwiYWRkTWFueSIsInNldE9uZSIsInNldE1hbnkiLCJzZXRBbGwiLCJ1cGRhdGVPbmUiLCJ1cGRhdGVNYW55IiwidXBzZXJ0T25lIiwidXBzZXJ0TWFueSIsInJlbW92ZU9uZSIsInJlbW92ZU1hbnkiLCJjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJzb3J0IiwibW9kZWxzIiwibW9kZWwiLCJtZXJnZSIsImFwcGxpZWRVcGRhdGVzIiwidXBkYXRlc18xIiwibmV3SWQiLCJyZXNvcnRFbnRpdGllcyIsImFyZUFycmF5c0VxdWFsIiwiYWxsRW50aXRpZXMiLCJuZXdTb3J0ZWRJZHMiLCJjcmVhdGVFbnRpdHlBZGFwdGVyIiwic29ydENvbXBhcmVyIiwiaW5zdGFuY2UiLCJzdGF0ZUZhY3RvcnkiLCJzZWxlY3RvcnNGYWN0b3J5Iiwic3RhdGVBZGFwdGVyIiwidXJsQWxwaGFiZXQiLCJuYW5vaWQiLCJzaXplIiwiTWF0aCIsInJhbmRvbSIsImNvbW1vblByb3BlcnRpZXMiLCJSZWplY3RXaXRoVmFsdWUiLCJGdWxmaWxsV2l0aE1ldGEiLCJtaW5pU2VyaWFsaXplRXJyb3IiLCJzaW1wbGVFcnJvciIsImNvbW1vblByb3BlcnRpZXNfMSIsInByb3BlcnR5IiwiY3JlYXRlQXN5bmNUaHVuayIsImNyZWF0ZUFzeW5jVGh1bmsyIiwidHlwZVByZWZpeCIsInBheWxvYWRDcmVhdG9yIiwicmVxdWVzdElkIiwicmVxdWVzdFN0YXR1cyIsInBlbmRpbmciLCJzZXJpYWxpemVFcnJvciIsInJlamVjdGVkV2l0aFZhbHVlIiwiYWJvcnRlZCIsImRpc3BsYXllZFdhcm5pbmciLCJBQyIsIkFib3J0Q29udHJvbGxlciIsImNsYXNzXzEiLCJzaWduYWwiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzcGF0Y2hFdmVudCIsIm9uYWJvcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVhc29uIiwidGhyb3dJZkFib3J0ZWQiLCJhYm9ydCIsImluZm8iLCJkaXNwYXRjaCIsImV4dHJhIiwiaWRHZW5lcmF0b3IiLCJhYm9ydENvbnRyb2xsZXIiLCJhYm9ydFJlYXNvbiIsInByb21pc2UyIiwiX2EiLCJfYiIsImZpbmFsQWN0aW9uIiwiY29uZGl0aW9uUmVzdWx0IiwiYWJvcnRlZFByb21pc2UiLCJlcnJfMSIsInNraXBEaXNwYXRjaCIsImlzVGhlbmFibGUiLCJnZXRQZW5kaW5nTWV0YSIsInJhY2UiLCJyZWplY3RXaXRoVmFsdWUiLCJmdWxmaWxsV2l0aFZhbHVlIiwiZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24iLCJ1bndyYXAiLCJ1bndyYXBSZXN1bHQiLCJ3aXRoVHlwZXMiLCJoYXNNYXRjaEZ1bmN0aW9uIiwibWF0Y2hlcyIsImlzQW55T2YiLCJtYXRjaGVycyIsImlzQWxsT2YiLCJoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YSIsInZhbGlkU3RhdHVzIiwiaGFzVmFsaWRSZXF1ZXN0SWQiLCJoYXNWYWxpZFJlcXVlc3RTdGF0dXMiLCJpc0FzeW5jVGh1bmtBcnJheSIsImlzUGVuZGluZyIsImFzeW5jVGh1bmtzIiwiYXN5bmNUaHVuayIsImNvbWJpbmVkTWF0Y2hlciIsImlzUmVqZWN0ZWQiLCJpc1JlamVjdGVkV2l0aFZhbHVlIiwiaGFzRmxhZyIsImlzRnVsZmlsbGVkIiwiaXNBc3luY1RodW5rQWN0aW9uIiwiYXN5bmNUaHVua3NfMSIsImFzc2VydEZ1bmN0aW9uIiwiZnVuYyIsImV4cGVjdGVkIiwibm9vcCIsImNhdGNoUmVqZWN0aW9uIiwib25FcnJvciIsImNhdGNoIiwiYWRkQWJvcnRTaWduYWxMaXN0ZW5lciIsImFib3J0U2lnbmFsIiwiY2FsbGJhY2siLCJvbmNlIiwiYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbiIsInRhc2siLCJsaXN0ZW5lciIsImNvbXBsZXRlZCIsImNhbmNlbGxlZCIsInRhc2tDYW5jZWxsZWQiLCJ0YXNrQ29tcGxldGVkIiwibGlzdGVuZXJDYW5jZWxsZWQiLCJsaXN0ZW5lckNvbXBsZXRlZCIsIlRhc2tBYm9ydEVycm9yIiwiY29kZSIsInZhbGlkYXRlQWN0aXZlIiwicmFjZVdpdGhTaWduYWwiLCJjbGVhbnVwIiwibm90aWZ5UmVqZWN0aW9uIiwiZmluYWxseSIsInJ1blRhc2siLCJ0YXNrMiIsImNsZWFuVXAiLCJlcnJvcl8xIiwic3RhdHVzIiwiY3JlYXRlUGF1c2UiLCJvdXRwdXQiLCJjcmVhdGVEZWxheSIsInBhdXNlIiwidGltZW91dE1zIiwic2V0VGltZW91dCIsIklOVEVSTkFMX05JTF9UT0tFTiIsImFsbSIsImNyZWF0ZUZvcmsiLCJwYXJlbnRBYm9ydFNpZ25hbCIsImxpbmtDb250cm9sbGVycyIsImNvbnRyb2xsZXIiLCJ0YXNrRXhlY3V0b3IiLCJjaGlsZEFib3J0Q29udHJvbGxlciIsInJlc3VsdDIiLCJkZWxheSIsImNhbmNlbCIsImNyZWF0ZVRha2VQYXR0ZXJuIiwic3RhcnRMaXN0ZW5pbmciLCJ0YWtlIiwicHJlZGljYXRlIiwidGltZW91dCIsInVuc3Vic2NyaWJlIiwidHVwbGVQcm9taXNlIiwicHJvbWlzZXMiLCJzdG9wTGlzdGVuaW5nIiwiZWZmZWN0IiwibGlzdGVuZXJBcGkiLCJnZXRPcmlnaW5hbFN0YXRlIiwiZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSIsImNyZWF0ZUxpc3RlbmVyRW50cnkiLCJlbnRyeSIsIlNldCIsImNhbmNlbEFjdGl2ZUxpc3RlbmVycyIsImNyZWF0ZUNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlIiwibGlzdGVuZXJNYXAiLCJjbGVhciIsInNhZmVseU5vdGlmeUVycm9yIiwiZXJyb3JIYW5kbGVyIiwiZXJyb3JUb05vdGlmeSIsImVycm9ySW5mbyIsImVycm9ySGFuZGxlckVycm9yIiwiYWRkTGlzdGVuZXIiLCJjbGVhckFsbExpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwiZGVmYXVsdEVycm9ySGFuZGxlciIsImNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVPcHRpb25zIiwiTWFwIiwiaW5zZXJ0RW50cnkiLCJkZWxldGUiLCJzZXQiLCJjYW5jZWxPcHRpb25zIiwiY2FuY2VsQWN0aXZlIiwiZmluZExpc3RlbmVyRW50cnkiLCJjb21wYXJhdG9yIiwiZXhpc3RpbmdFbnRyeSIsImVudHJ5MiIsIm1hdGNoUHJlZGljYXRlT3JUeXBlIiwibm90aWZ5TGlzdGVuZXIiLCJhcGkiLCJpbnRlcm5hbFRhc2tDb250cm9sbGVyIiwibGlzdGVuZXJFcnJvcl8xIiwiQm9vbGVhbiIsImZvcmsiLCJzdWJzY3JpYmUiLCJyYWlzZWRCeSIsImNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlIiwib3JpZ2luYWxTdGF0ZSIsImN1cnJlbnRTdGF0ZSIsImxpc3RlbmVyRW50cmllcyIsImxpc3RlbmVyRW50cmllc18xIiwicnVuTGlzdGVuZXIiLCJwcmVkaWNhdGVFcnJvciIsImNsZWFyTGlzdGVuZXJzIiwiU0hPVUxEX0FVVE9CQVRDSCIsInByZXBhcmVBdXRvQmF0Y2hlZCIsInByb21pc2UiLCJxdWV1ZU1pY3JvdGFza1NoaW0iLCJxdWV1ZU1pY3JvdGFzayIsImdsb2JhbCIsImdsb2JhbFRoaXMiLCJjYiIsImVyciIsImNyZWF0ZVF1ZXVlV2l0aFRpbWVyIiwibm90aWZ5IiwickFGIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYXV0b0JhdGNoRW5oYW5jZXIiLCJzdG9yZSIsIm5vdGlmeWluZyIsInNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrIiwibm90aWZpY2F0aW9uUXVldWVkIiwibGlzdGVuZXJzIiwicXVldWVDYWxsYmFjayIsInF1ZXVlTm90aWZpY2F0aW9uIiwibm90aWZ5TGlzdGVuZXJzIiwibCIsImxpc3RlbmVyMiIsIndyYXBwZWRMaXN0ZW5lciIsImlzRmx1eFN0YW5kYXJkQWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\n");

/***/ })

};
;